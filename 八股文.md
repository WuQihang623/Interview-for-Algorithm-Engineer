<h1 style="text-align:center;">面试内容
</h1>
<h2 style="text-align:center;"> 计算机基础知识</h2>

### C++中程序的开发流程

**编译：**使用编译器将这个C++程序“翻译”成汇编语言。编译器所做的工作实际上是一种由高级语言到汇编语言的等价变换。

**汇编：**将汇编语言翻译成机器语言指令。汇编器对汇编语言进行一系列处理后最终产生的输出结构称为目标代码，它是某种计算机的机器指令（二进制），并且在功能上与源代码完全等价。保存源代码和目标代码的文件分别称为源文件和目标文件（ .obj）。

**链接：**要将汇编器产生的目标代码变成可执行程序还需要最后一个步骤——链接。链接工作是由“链接器”完成的，它将编译后产生的一个或多个目标文件与程序中用到的库文件链接起来，形成一个可以在操作系统中直接运行的可执行程序。（linux中的.o文件）

**运行和调试：**我们接下来就可以执行程序了。如果出现问题我们可以进行调试debug。



### 你了解设计模式吗？在python中如何实现单例模式？

- 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。
- 工厂模式（Factory Pattern）：定义一个用于创建对象的接口，但将实际的创建工作推迟到子类中。
- 抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定其具体类。
- 建造者模式（Builder Pattern）：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。

#### 如何实现单例模式

1. 在定义类前采用修饰器@singleton

2. 使用了类方法 `__new__`，在对象创建之前进行检查，确保只有一个实例被创建，并且保证了线程安全性。

   ```python
   class Singleton:
       _instance = None
   
       def __new__(cls, *args, **kwargs):
           if cls._instance is None:
               cls._instance = super().__new__(cls, *args, **kwargs)
           return cls._instance
   
   class MyClass(Singleton):
       def __init__(self, name):
           self.name = name
   
   # 创建实例
   obj1 = MyClass("instance1")
   obj2 = MyClass("instance2")
   
   print(obj1.name)  # 输出：instance1
   print(obj2.name)  # 输出：instance1（因为它是同一个实例）
   ```

   #### 单例模式的优点：

   1. **全局唯一实例：** 保证一个类只有一个实例，对于频繁使用的对象，可以节省系统资源。
   2. **延迟实例化：** 可以延迟实例的创建，直到需要时再进行初始化。
   3. **避免竞态条件：** 在多线程环境中，单例模式可以避免竞态条件，确保只有一个实例被创建。

   #### 单例模式的缺点：

   1. **全局状态：** 单例模式引入了全局状态，可能导致程序的复杂性增加。
   2. **隐藏依赖：** 单例模式可能隐藏了类之间的依赖关系，使得代码难以理解和维护。

   #### 适用场景：

   1. 当一个系统只需要一个实例来协调行为时。

   2. 当实例需要被频繁访问，而不希望通过参数传递来获取实例。

   3. 当一个类的实例需要被全局访问，并且这个实例负责协调操作。

   #### 如何实现工厂模式

   ```pyth
   class Product:
       def operation(self):
           pass
   
   class ConcreteProduct1(Product):
       def operation(self):
           return "Operation from ConcreteProduct1"
   
   class ConcreteProduct2(Product):
       def operation(self):
           return "Operation from ConcreteProduct2"
   
   class SimpleFactory:
       @staticmethod
       def create_product(product_type):
           if product_type == "product1":
               return ConcreteProduct1()
           elif product_type == "product2":
               return ConcreteProduct2()
           else:
               raise ValueError("Invalid product type")
   
   # 使用工厂创建对象
   factory = SimpleFactory()
   product1 = factory.create_product("product1")
   product2 = factory.create_product("product2")
   
   print(product1.operation())  # 输出：Operation from ConcreteProduct1
   print(product2.operation())  # 输出：Operation from ConcreteProduct2
   
   ```

   #### 工厂模式的优点：

   1. **封装对象创建逻辑：** 工厂模式将对象的创建过程封装在工厂类中，客户端无需了解对象的创建过程，只需通过工厂类获取对象。
   2. **可扩展性：** 新增产品类时，只需要扩展工厂类而不需要修改客户端代码，符合开闭原则。
   3. **解耦：** 将具体产品类和客户端代码解耦，使得系统更易于维护和扩展。

   #### 工厂模式的缺点：

   1. **类数量增多：** 随着产品类的增多，可能导致工厂类的数量也增多，使得代码结构复杂。
   2. **不符合开闭原则的变体：** 在简单工厂模式中，每次新增产品都需要修改工厂类，不符合开闭原则。

   #### 工厂模式适用情景：

   1. 当一个系统需要独立于其创建、组合和表示时。

   2. 当一个系统需要多个产品系列中的一种，并且客户端不关心这些对象的创建细节。

   3. 当一个系统需要动态配置对象。

   

### C++有什么特性？

1. **面向对象编程（Object-Oriented Programming, OOP）**：C++ 支持面向对象编程，包括类、对象、继承、多态等概念，使得代码结构更加模块化和可重用。
2. **泛型编程（Generic Programming）**：C++ 支持泛型编程，通过模板（template）实现通用的算法和数据结构，提高了代码的灵活性和复用性。
3. **多重继承（Multiple Inheritance）**：C++ 允许一个类继承自多个基类，这使得在设计复杂系统时能够更好地表达对象之间的关系。
4. **内存管理**：C++ 具有灵活的内存管理能力，包括手动内存管理（使用 new 和 delete 操作符）和智能指针（如 std::shared_ptr、std::unique_ptr），可以有效地管理内存资源。
5. **运算符重载（Operator Overloading）**：C++ 允许用户重载运算符，使得用户定义的类型可以像内置类型一样使用运算符进行操作。
6. **异常处理（Exception Handling）**：C++ 提供了异常处理机制，通过 try-catch 块捕获和处理异常，使得程序能够更加健壮和可靠。
7. **标准模板库（Standard Template Library, STL）**：STL 是 C++ 标准库的一部分，包含了丰富的通用数据结构和算法，如容器（vector、list、map 等）和算法（排序、查找、遍历等），提高了编程效率和代码质量。
8. **高效的性能**：C++ 是一种高性能的语言，具有接近于底层的控制和优化能力，适用于开发对性能要求较高的系统和应用程序。
9. **平台独立性**：C++ 是一种跨平台的语言，可以在多种操作系统上编译和运行，如 Windows、Linux、macOS 等。
10. **友元函数和友元类（Friend Function and Friend Class）**：C++ 允许将函数或类声明为另一个类的友元，使得这些函数或类能够访问该类的私有成员。
11. **支持低级操作**：C++ 允许直接操作内存，包括指针、引用、位操作等，使得开发者能够更加灵活地进行系统级别的编程。

#### 面向对象编程的特点和核心概念：

1. **类与对象**：
   - 类（Class）是一种用户自定义的数据类型，用于描述一类对象的共同属性和行为。类可以看作是对象的模板或蓝图。
   - 对象（Object）是类的实例，具体化了类的属性和行为。对象是程序中的实体，具有状态、行为和标识。
2. **封装（Encapsulation）**：
   - 封装是指将数据和操作封装在类的内部，隐藏了对象的内部实现细节，只提供公共的接口供外部访问。
   - 封装可以提高代码的安全性和可维护性，减少了对象之间的耦合度。
3. **继承（Inheritance）**：
   - 继承是一种机制，允许一个类（子类）继承另一个类（父类）的属性和方法，并且可以在此基础上进行扩展或修改。
   - 继承可以提高代码的重用性，减少了重复编写代码的工作量。
4. **多态（Polymorphism）**：
   - 多态是指同一个操作作用于不同的对象上时，可以产生不同的行为。
   - 多态通过函数重载、运算符重载和虚函数等机制实现，使得程序更加灵活和可扩展。

面向对象编程的主要目标是提高代码的**重用性、可扩展性和可维护性**，通过封装、继承和多态等特性，使得程序结构更加清晰和易于理解。

#### 标准模板库

STL 主要包含以下三个组件：

1. **容器（Containers）**： 容器是用来存储数据的数据结构，STL 提供了多种类型的容器，包括顺序容器和关联容器。
   - 顺序容器（Sequential Containers）：如 vector、list、deque、array 等，用于按顺序存储和访问元素。
   - 关联容器（Associative Containers）：如 set、map、multiset、multimap 等，用于按键值进行快速查找和访问元素。
2. **算法（Algorithms）**： 算法是对容器中的数据进行操作和处理的函数，STL 提供了一系列的通用算法，如排序、查找、合并、计算等。 这些算法通过迭代器（Iterators）来访问容器中的元素，使得算法与数据结构解耦合，提高了算法的复用性和灵活性。
3. **迭代器（Iterators）**： 迭代器是一种类似于指针的对象，用于在容器中遍历和访问元素，STL 提供了多种类型的迭代器，如输入迭代器、输出迭代器、正向迭代器、随机访问迭代器等。 迭代器提供了统一的接口，使得算法可以在不同类型的容器上进行操作，而无需关心容器的具体实现细节。



### cpp的动态链接库和静态链接库的不同

**静态链接：**在编译时（确切地说是链接阶段）完成。编译器将目标文件（.o 或 .obj 文件）与所需的静态库文件合并，生成最终的可执行文件。这个过程中，静态库中的代码和数据被直接嵌入到可执行文件中。

**动态链接：**在运行时完成。编译阶段仅将对动态库函数的引用信息包含在可执行文件中，而实际的库代码并未嵌入。当程序启动或首次访问到动态库函数时，操作系统负责加载相应的库文件到内存，并完成函数地址的解析和绑定。



#### 虚函数的概念

通过在基类中声明虚函数，派生类可以覆盖（override）基类中的虚函数，从而在运行时确定调用的是哪个版本的函数。这种机制称为动态绑定（dynamic binding）或运行时多态（runtime polymorphism）。

**1. 在基类中声明虚函数：** 在基类中将函数声明为虚函数，使用 `virtual` 关键字进行修饰。这样，派生类可以选择性地覆盖基类中的虚函数。

```C++
class Base {
public:
    virtual void show() {
        cout << "Base class function" << endl;
    }
};
```

**2. 在派生类中覆盖虚函数：** 派生类可以重新定义基类中的虚函数，实现自己特定的行为。派生类中的函数声明必须与基类中的虚函数声明相匹配。

```C++
class Derived : public Base {
public:
    void show() override {
        cout << "Derived class function" << endl;
    }
};
```

3. **动态绑定：** 当基类指针（或引用）指向派生类对象时，通过虚函数的动态绑定机制，在运行时确定调用的是派生类中的版本还是基类中的版本。这样可以根据对象的实际类型来调用对应的函数。

```C++
int main() {
    Base* ptr = new Derived();
    ptr->show(); // 调用的是Derived类中的show函数
    delete ptr;
    return 0;
}
```

### C++构造函数和析构函数可以是虚函数吗

1. 构造函数不可以是虚函数

2. 析构函数常常是虚函数：析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。

   若析构函数是虚函数，delete 时，基类和子类都会被释放；若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。

   

### C++继承时，构造函数的调用顺序

在子类的构造函数中，首先会调用父类的构造函数，然后再执行子类自己的构造函数体。



### 静态成员变量如何初始化

1. 类外部初始化：由于静态成员变量是类级别的，不在任何对象内部，因此它们不能在类的构造函数中初始化。相反，应在类定义之外、通常是在源文件（`.cpp`或`.cc`文件）中进行显式初始化。初始化时使用作用域解析运算符 `::` 指明静态成员所属的类。

```C++
int MyClass::myStaticVar = 100;  // 直接赋值初始化
int MyClass::myStaticVar {200};  // 列表初始化（C++11起支持）
```

2. 类内部声名时初始化（仅限常量整型或者枚举类型）
3. 使用类的静态成员函数进行初始化



### const成员函数

这些函数在被调用时不会修改对象的状态。`const`成员函数内部不能修改类的非静态成员变量，但可以调用其他`const`成员函数，可以访问和调用类的成员变量，但不能修改非`mutable`成员变量的值。

```C++
class MyClass {
public:
    void nonConstFunction() {
        // 这个函数可以修改对象的状态
    }

    void constFunction() const {
        // 这个函数不会修改对象的状态
    }
};
```

### static成员函数

静态成员函数与非静态成员函数有所不同，它们不依赖于任何特定的对象实例，因此**可以在不创建对象实例的情况下直接调用**。**静态成员函数可以访问类的静态成员变量和其他静态成员函数，但不能访问非静态成员变量或非静态成员函数。**

```C++
class MyClass {
private:
    static int staticMember;

public:
    static void staticMemberFunction() {
        std::cout << "Static member function called." << std::endl;
        std::cout << "Static member value: " << staticMember << std::endl;
    }

    static int getStaticMember() {
        return staticMember;
    }
};
```



### 内联函数

通过在函数定义前加上关键字 `inline` 来将函数声明为内联函数。编译器会尽量将内联函数的调用处替换为函数体的实际代码，以提高程序的执行效率。但是，编译器会根据情况决定是否真正进行内联展开，因此 `inline` 关键字只是对编译器的一个建议，编译器有权忽略这个建议。

1. 减少了函数调用的开销，因为直接展开代码而不是通过调用栈来执行。
2. 提高了程序的执行效率，特别是对于频繁调用的短小函数。
3. 可以避免一些宏定义带来的副作用和错误。

但是，内联函数也有一些限制和缺点：

1. 内联函数的代码会被直接插入到调用处，可能会导致程序体积增大。
2. 内联函数适合用于短小的函数，如果函数体过长，可能会导致代码膨胀，甚至降低程序的性能。
3. 每个调用内联函数的地方都要复制一份函数的代码，可能会导致代码冗余。



### 宏定义（不需要加分号）

宏定义可以把一个名称指定成任何一个文本。在完成宏定义后，无论宏名称出现在源代码的何处，预处理器都会将其替换成指定的文本。

```C++
#define WeThinkIn 666688889999
#define R(a,b) (a/b)
```

**优点：**

1. 方便程序修改
2. 相比于函数，提高了程序运行效率（无需调用函数这个流程）



### inline和define的区别

- **`#define`**：它是预处理器指令，属于预编译阶段的操作。`#define` 用于定义一个宏，宏展开本质上是文本替换。编译器在编译前的预处理阶段，会将源代码中所有出现宏名的地方替换为宏定义中的文本。这种替换是无条件的、机械的，不进行类型检查或语法分析。宏可以用于定义常量、简单函数样式的宏（带有参数的宏）以及代码块的宏。
- **`inline`**：它是一个C++关键字，用于指示编译器尝试将函数体直接插入到每个调用该函数的地方（即内联展开），而不是通过传统的函数调用机制。内联是在编译阶段进行的，编译器根据上下文判断是否接受内联请求，并进行相应的优化。内联函数仍然是真正的函数，遵循C++的语法规则和类型检查。内联函数主要用于函数级别的代码复用，它支持参数、返回值、局部变量、异常处理、模板等完整的函数特性。



### C++中的typedef关键字

```C++
// 为基本数据类型定义新的类型名
typedef char* WeThinkIn_point;
// 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称
typedef struct target_Object
{
    int x;
    int y;
} WeThinkIn_Object;
```

**typedef与宏定义的区别：**

1. 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

2. 宏替换发生在预处理阶段，属于文本恒等替换；typedef是编译中发挥作用。

3. 宏定义参数没有类型，不进行类型检查；typedef参数具有类型，需要检查类型。

4. 宏不是语句，不用在最后加分号；typedef是语句，要加分号标识结束。

5. 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。



### 重写与重载的区别

**重写：**重写发生在继承关系中，当子类定义了一个与父类中某个虚函数（在C++中需使用`virtual`关键字声明）同名、同参数列表、同返回类型的方法时，称为重写。子类中的方法覆盖了父类中的同名方法。目的是为了实现多态性。

**重载：**重载指的是在同一作用域（通常指同一个类）内，可以有多个同名函数，但这些函数的参数列表（包括参数个数、类型、顺序或参数的默认值）必须不同，返回类型可以相同也可以不同（但不能仅凭返回类型区分重载）。



### 友元函数

友元函数的声明通常放在类的声明中，并在函数声明前加上 `friend` 关键字。这样做的效果是，声明为友元函数的函数可以直接访问类的私有成员和保护成员，就像它们是类的成员函数一样。



### vector扩容

标准库中的 `std::vector` 是一种动态数组，它可以根据需要动态地增长或缩小其大小。

1. 当向 `std::vector` 中添加新元素时，会首先检查容器的当前大小（即元素个数）和容量（即可容纳的元素个数）。
2. 如果当前大小小于容量，则说明向 `std::vector` 添加新元素时不需要扩容，直接将元素添加到数组末尾即可。
3. 如果当前大小等于容量，则说明容器已经满了，需要进行扩容操作。通常情况下，容量的增长是按照某种固定的倍数进行的（如翻倍或加倍）。
4. 扩容操作包括分配新的内存空间，并将原有元素拷贝到新的内存空间中。



### 程序运行时堆和栈的区别

**存储结构上：**

栈是一种线性结构，存储方式是先进后出（FILO）。数据在栈中是连续存储的，栈的空间由系统自动管理，通常会在程序运行时分配一块固定大小的内存。每当一个函数被调用时，系统会自动为该函数分配一块栈空间，函数的局部变量和函数参数等数据都存储在这个栈空间中。

堆是一种非连续的存储结构，它的存储方式没有固定的顺序。堆的空间由程序员手动分配和释放，通常通过 `new` 和 `delete`、`malloc` 和 `free` 等操作来进行管理。

**生命周期：**

栈中的数据的生命周期与函数调用的生命周期相关联。

堆中的数据的生命周期由程序员手动控制。



### vector是怎么删除元素的，时间复杂度

1. 使用 `erase()` 函数删除指定位置的元素， 时间复杂度为`O(n)`，要将元素往前移：

```C++
std::vector<int> vec = {1, 2, 3, 4, 5};
vec.erase(vec.begin() + 2); // 删除索引为2的元素（值为3）
```

2. 使用 `pop_back()` 函数删除末尾的元素， 时间复杂度为`O(1)`：

```C++
std::vector<int> vec = {1, 2, 3, 4, 5};
vec.pop_back(); // 删除末尾的元素（值为5）
```

### vector 容器 push_back 和 emplace_back 的区别

当使用`push_back`时，如果要添加的元素是已存在的对象，会进行一次元素拷贝构造。这意味着会调用元素类型的拷贝构造函数，将一个已存在的对象复制到容器中。

`emplace_back`在容器中直接构造一个新的元素，而不是复制已有的对象。这意味着会调用元素类型的构造函数，将参数传递给构造函数以创建一个新的对象。



### i++ ++i区别

`i++`是一个后缀递增操作符，它先返回`i`的值，然后将`i`的值增加1。

`++i`是一个前缀递增操作符，它先将`i`的值增加1，然后再返回`i`的值。



### explicit 关键字

`explicit`关键字通常用于修饰类的单参数构造函数，用以防止隐式类型转换。当一个构造函数被声明为`explicit`时，它将不会被用于隐式类型转换，只能用于显式构造。

```C++
class MyClass {
public:
    explicit MyClass(int x) : data(x) {}
    int getData() const { return data; }
private:
    int data;
};

void processMyClass(const MyClass& obj) {
    // 处理 MyClass 对象的函数
}

int main() {
    MyClass obj1 = 10; // 错误，因为构造函数是 explicit 的
    MyClass obj2(10); // 正确，显式调用构造函数来创建对象

    processMyClass(10); // 错误，因为构造函数是 explicit 的
    processMyClass(MyClass(10)); // 正确，显式调用构造函数来创建对象并传递给函数
}
```



### 构造函数初始化列表与内部赋值的区别

构造函数初始化列表使用冒号`:`跟随在构造函数声明之后，然后列出成员变量和它们的初始化值。

```C++
class MyClass {
public:
    MyClass(int x, int y) : data1(x), data2(y) {}
private:
    int data1;
    int data2;
};
```

初始化列表的方式**更高效**，因为它直接在对象构造时对成员变量进行初始化，而不是先创建对象再调用赋值操作。

内部赋值的方式相对较低效，因为它需要先创建对象，然后再进行赋值操作。

对于`const`成员变量和引用成员变量，必须使用初始化列表来初始化，因为它们不能在构造函数内部赋值。

```C++
class MyClass {
public:
    MyClass(int x) : constData(x), refData(x) {}
private:
    const int constData;
    int& refData;
};
```



### 实现一个String类

```C++
#include <iostream>
#include <cstring> // 用于 strlen 和 strcpy 函数

class String {
private:
    char *str; // 存储字符串的字符数组
    size_t length; // 字符串长度

public:
    // 默认构造函数
    String() : str(nullptr), length(0) {}

    // 带参构造函数
    String(const char *s) : str(nullptr), length(0) {
        if (s != nullptr) {
            length = std::strlen(s);
            str = new char[length + 1];
            std::strcpy(str, s);
        }
    }

    // 拷贝构造函数
    String(const String &other) : str(nullptr), length(other.length) {
        if (other.str != nullptr) {
            str = new char[length + 1];
            std::strcpy(str, other.str);
        }
    }

    // 析构函数
    ~String() {
        delete[] str;
    }

    // 赋值运算符重载
    String& operator=(const String &other) {
        if (this != &other) {
            delete[] str; // 释放原有的内存
            length = other.length;
            if (other.str != nullptr) {
                str = new char[length + 1];
                std::strcpy(str, other.str);
            } else {
                str = nullptr;
            }
        }
        return *this;
    }

    // 字符串连接
    String operator+(const String &other) const {
        String result;
        result.length = length + other.length;
        result.str = new char[result.length + 1];
        if (str != nullptr)
            std::strcpy(result.str, str);
        if (other.str != nullptr)
            std::strcat(result.str, other.str);
        return result;
    }

    // 获取字符串长度
    size_t getLength() const {
        return length;
    }

    // 获取字符串内容
    const char* c_str() const {
        return str;
    }
};
```



### STL容器底层实现

**顺序容器**

| 容器   | 数据结构                             |
| ------ | ------------------------------------ |
| vector | 数组                                 |
| deque  | 数个缓冲区相接，由一个中央控制器管理 |
| list   | 双向链表                             |

- 随机访问
  - vector：支持快速随机访问，一次指针解引用
  - deque：支持随机访问，两次指针解引用（中央控制器和缓冲区两次）
  - list：不支持随机访问
- 内存管理：
  - vector：扩充时须将所有的元素拷贝到新位置
  - deque：按需扩充一个缓冲区大小，无需拷贝
  - list：为各节点单独分配内存
- 增删元素：
  - vector：在尾部可快速增删，中间插入会导致之后的元素拷贝
  - deque：在头尾可快速增删，中间插入会导致元素拷贝
  - list：在任意位置都可快速增删

**关联容器**

可以快速查找`O(logN)`的容器，且可以按键排序

|   容器   | 数据结构 | 集合内容 | 键是否唯一 |
| :------: | :------: | :------: | :--------: |
|   set    |  红黑树  |    键    |     是     |
|   map    |  红黑树  |  键值对  |     是     |
| multiset |  红黑树  |    键    |     否     |
| multimap |  红黑树  |  键值对  |     否     |

**无序关联容器**

|        容器        | 数据结构 | 集合内容 | 键是否唯一 |
| :----------------: | :------: | :------: | :--------: |
|   unordered_set    |  哈希表  |    键    |     是     |
|   unordered_map    |  哈希表  |  键值对  |     是     |
| unordered_multiset |  哈希表  |    键    |     否     |
| unordered_multimap |  哈希表  |  键值对  |     否     |

**容器适配器**

在其他容器的接口上进行封装和改写实现

|      容器      | 默认底层容器 |      描述      |
| :------------: | :----------: | :------------: |
|     stack      |    deque     | 堆栈，后进先出 |
|     queue      |    deque     | 队列，先进先出 |
| priority_queue |    vector    |    优先队列    |

stack 和 queue 默认用 deque 实现为了让当数据量很大时，不会因元素移动导致过多的时间消耗。而 priority_queue 利用 vector 则是因为为了实现优先队列用到了 [heap](https://zinglix.xyz/2018/05/27/stl-heap/) 相关的函数，其中用到了大量的随机访问。



### 排序算法有哪些，哪些是稳定的

1. **冒泡排序（Bubble Sort）**：
   - 冒泡排序是一种简单的交换排序算法，它反复比较相邻的元素并交换，直到整个序列有序。
   - 稳定性：稳定。
2. **选择排序（Selection Sort）**：
   - 选择排序每次从未排序部分选择最小（或最大）的元素放到已排序部分的末尾。
   - 稳定性：不稳定。
3. **插入排序（Insertion Sort）**：
   - 插入排序将序列分为已排序和未排序两部分，每次从未排序部分取出一个元素插入到已排序部分的合适位置。
   - 稳定性：稳定。
4. **快速排序（Quick Sort）**：
   - 快速排序使用分治法，每次选择一个基准元素，将小于基准的元素放在基准的左边，大于基准的元素放在右边，然后递归地对左右两部分进行排序。
   - 稳定性：不稳定。
5. **归并排序（Merge Sort）**：
   - 归并排序将序列递归地分成两半，然后对每个子序列进行排序，最后合并两个有序子序列。
   - 稳定性：稳定。
6. **堆排序（Heap Sort）**：
   - 堆排序使用堆这种数据结构，每次从堆中取出最大（或最小）的元素放在已排序部分的末尾，然后调整堆保持其性质。
   - 稳定性：不稳定。
7. **计数排序（Counting Sort）**：
   - 计数排序统计每个元素出现的次数，然后按照元素的值顺序重新排列。
   - 稳定性：稳定。
8. **桶排序（Bucket Sort）**：
   - 桶排序将元素分配到有限数量的桶中，对每个桶中的元素进行排序，然后按照桶的顺序将元素依次取出。
   - 稳定性：稳定。
9. **基数排序（Radix Sort）**：
   - 基数排序按照元素的各个位进行排序，从低位到高位依次进行。
   - 稳定性：稳定。



### struct 和 class 的区别

- 在 `struct` 中，默认的访问权限是公共的（`public`），即结构体中的成员默认为公共成员。
- 在 `class` 中，默认的访问权限是私有的（`private`），即类中的成员默认为私有成员。
- 语义上，`struct` 常常被用来表示一种数据的聚合，而 `class` 则常常被用来表示一种对象的抽象，其中可能包含了更多的方法和行为。



### struct中的内存对齐

**什么是内存对齐？**计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是有效对齐值的倍数。

**什么是有效对齐值？**计算机系统有默认对齐系数n,可以通过#pragma pack(n)来指定。有效对齐值就等与该对齐系数和结构体中最长的数据类型的长度两者最小的那一个值,比如对齐系数是8,而结构体中最长的是int,4个字节,那么有效对齐值为4。

**为什么要内存对齐？**假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中。当4字节存取粒度的处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作，整体效率较低。

**struct内存占用如何计算？**结构体的内存计算方式遵循以下规则：

1. 数据成员对齐规则：第一个数据成员放在offset为0的地方，以后的每一个成员的offset都必须是该成员的大小与有效对齐值相比较小的数值的整数倍,例如第一个数据成员是int型，第二个是double，有效对齐值为8,所以double的起始地址应该为8,那么第一个int加上内存补齐用了8个字节
2. 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部有效对齐值的整数倍地址开始存储。(比如struct a中存有struct b，b里有char, int, double，那b应该从8的整数倍开始存储)
3. 结构体内存的总大小，必须是其有效对齐值的整数倍，不足的要补齐。



### 指针和引用的区别

**操作符：**

指针使用 `*` 来声明指针变量和解引用操作符，使用 `&` 来获取变量的地址。

引用使用 `&` 来声明引用变量，并在声明时必须初始化为另一个变量，之后就可以像使用原始变量一样使用引用。

**nullptr：**指针可以是空指针（nullptr），引用不能是空的

**重复赋值：**

指针可以在其生命周期内多次改变指向的对象，可以重新赋值为不同的地址。

引用一旦初始化后，就不能改变引用的对象，它始终引用同一个对象，因此无法重新赋值为其他对象。

**内存管理：**

指针需要手动管理内存，需要显式地分配和释放内存，存在内存泄漏和悬空指针的风险。

引用不需要手动管理内存，它只是给变量起了一个别名，不占用额外的内存，因此不会出现内存泄漏和悬空引用的问题。



### 数组，链表，哈希表的区别

**数组：**

数组是一种线性结构，由相同类型的元素按顺序排列组成。

数组的元素在内存中是连续存储的，因此可以通过索引直接访问任何元素。

数组的大小是固定的，一旦分配了空间，就不能动态改变数组的大小。

插入和删除元素时，需要移动其他元素以保持连续性，因此在插入和删除操作上的效率较低。

**链表：**

链表是一种线性结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。

链表的节点在内存中可以是不连续的，因此可以动态地分配和释放节点。

链表的大小可以动态增长或缩小，不受固定大小的限制。

插入和删除元素时，只需要改变节点的指针，不需要移动其他元素，因此在插入和删除操作上的效率较高。

**哈希表：**

哈希表是一种键值对存储结构，通过哈希函数将键映射到存储桶（Bucket）中。

哈希表的查找、插入和删除操作的平均时间复杂度是常数时间 O(1)，但最坏情况下可能会退化为线性时间 O(n)

哈希表的空间利用率通常较高，但是需要根据实际情况合理选择哈希函数和解决冲突的方法。



### 堆和栈的区别

**栈（Stack）：**主要用于存储局部变量、函数参数和返回地址等临时性数据。函数调用结束后，对应的栈帧会被自动销毁，释放其占用的内存。栈上的数据遵循**后进先出（LIFO）原则**，与函数调用的深度和顺序紧密相关。**栈的管理由编译器和操作系统自动完成。**栈内存的分配是连续的。**栈内存分配和释放的开销小**，几乎可以忽略不计，因此栈非常适合存储短期、小规模的数据。每个线程拥有独立的栈空间，线程间互不影响，因此**栈上的数据天然具有线程安全性**。

**堆（Heap）:**用于动态分配内存，存储那些在编译时无法确定大小，或者需要在整个程序生命周期内持续存在的数据。堆上的数据没有固定的生命周期，直到程序员显式地使用`delete`、`free`等函数释放内存，否则内存不会自动回收。**堆的管理由程序员手动控制。**堆内存分配则是动态且无序的。**堆内存分配和释放的开销相对较大。** **堆内存是全局共享的**，多个线程可能同时访问同一块堆内存，如果没有适当的同步控制，可能会引发数据竞争或死锁等问题。



### 拷贝构造

拷贝构造函数（Copy Constructor）是C++中的特殊构造函数之一，用于创建一个新对象并将其初始化为另一个同类型的对象的副本。

```C++
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        // 在这里进行拷贝构造的具体操作，通常是将成员变量逐一复制
        // 可以通过 const 引用来避免对参数对象进行修改
    }
};
```

在拷贝构造函数中，通常需要将参数对象的成员变量逐一复制到新对象中，以创建一个新对象并保留原始对象的副本。为了避免修改参数对象，通常将参数对象声明为 **const 引用**。

如果没有显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。默认的拷贝构造函数会对对象的每个成员变量进行**浅复制**。

但是对于包含**指针成员**的类，通常需要自定义拷贝构造函数以执行**深度复制**，以避免浅复制带来的问题，比如浅拷贝可能会导致多个对象共享同一块内存空间，当一个对象的内存释放时，会影响到其他对象的数据。



### 浅拷贝和深拷贝

浅拷贝是指将一个对象的值复制到另一个对象，对于指针成员，只是简单地复制指针的值（地址），而不是复制指针所指向的内容。

深拷贝是指将一个对象的值复制到另一个对象，对于指针成员，会创建一个新的内存空间，并将指针所指向的内容也复制一份到新的内存空间中。

```C++
class ShallowCopy {
public:
    int* data;

    ShallowCopy(const ShallowCopy& other) : data(other.data) {}  // 浅拷贝构造函数

    // 析构函数释放 data 指向的内存
    ~ShallowCopy() { delete data; }
};

class DeepCopy {
public:
    int* data;

    DeepCopy(const DeepCopy& other) : data(new int(*other.data)) {}  // 深拷贝构造函数

    // 析构函数释放 data 指向的内存
    ~DeepCopy() { delete data; }
};
```



### Python与C++的区别

1. **语法和风格：**
   - Python 的语法简洁清晰，采用缩进来表示代码块，没有大括号；而 C++ 的语法更加严格，采用分号和大括号来表示代码块。
   - Python 是一种解释型语言，代码无需编译即可执行；而 C++ 是一种编译型语言，需要先编译成机器码再执行。
2. **类型系统：**
   - Python 是一种动态类型语言，变量的类型在运行时确定，无需显式声明；而 C++ 是一种静态类型语言，变量的类型在编译时确定，需要显式声明。
   - Python 的变量可以指向任意类型的对象；而 C++ 的变量必须指定特定类型，并且类型在编译时是固定的。
3. **内存管理：**
   - Python 使用自动内存管理机制（垃圾回收），通过引用计数和循环垃圾收集来管理内存；而 C++ 需要程序员手动管理内存，包括分配和释放内存。
   - Python 的内存管理机制简化了程序开发，但可能导致性能损失和内存泄漏；而 C++ 的手动内存管理更加灵活，但需要程序员更加小心地处理内存。
4. **面向对象编程：**
   - Python 和 C++ 都支持面向对象编程，但其实现方式有所不同。
   - Python 的面向对象特性更加简单和灵活，支持动态继承、动态绑定等特性；而 C++ 的面向对象特性更加丰富，包括多重继承、虚函数、纯虚函数等。
5. **标准库和生态系统：**
   - Python 拥有丰富的标准库和第三方库，涵盖了几乎所有领域的应用开发，如科学计算、网络编程、Web 开发等；而 C++ 的标准库和第三方库相对较少，需要程序员自己去选择和引入。
6. **适用场景：**
   - Python 适用于快速开发、原型设计、数据分析、科学计算等领域，尤其擅长处理复杂的业务逻辑和高层次的任务。
   - C++ 适用于系统编程、游戏开发、嵌入式系统、性能优化等领域，尤其擅长处理底层的系统级别的任务和对性能要求较高的场景。

### 在项目中使用过多线程吗，是如何实现的？

1. **线程创建：** 程序员可以使用操作系统提供的线程库（如 POSIX 线程库 pthreads）或语言级别的多线程库（如 Java 中的 `Thread` 类）来创建线程。线程创建时需要指定线程函数或线程对象，并传递相应的参数。
2. **线程调度：** 操作系统负责线程的调度和管理，根据线程的优先级、状态和调度策略来决定哪个线程可以获得 CPU 时间片执行任务。常见的调度策略包括先来先服务（FCFS）、最短作业优先（SJF）、轮转调度（Round Robin）等。
3. **线程同步：** 多线程程序中，可能会存在共享资源的竞争和冲突，需要通过同步机制来确保多个线程之间的数据访问安全。常见的线程同步机制包括互斥锁（Mutex）、信号量（Semaphore）、条件变量（Condition Variable）等。
4. **线程通信：** 多线程程序中的线程之间可能需要进行通信和协作，以实现共同的任务目标。线程通信机制可以通过共享内存、消息队列、管道等方式来实现。
5. **线程销毁：** 线程执行完成后，需要及时释放线程所占用的资源，以防止资源泄漏和系统资源浪费。操作系统负责线程的销毁和资源回收。

#### 1. 互斥锁（Mutex）：

**概念：** 互斥锁是一种用于保护临界区的同步机制，用于确保在同一时刻只有一个线程可以访问共享资源。当一个线程进入临界区时，它会尝试获得互斥锁，如果互斥锁已被其他线程占用，则该线程会被阻塞，直到互斥锁被释放。

**特点：**

- 互斥锁是一种二进制锁，只有两种状态：锁定和解锁。
- 只有成功获得互斥锁的线程才能进入临界区，其他线程被阻塞。
- 互斥锁是一种独占锁，只能由获得锁的线程释放。

#### 2. 信号量（Semaphore）：

**概念：** 信号量是一种计数器，用于控制同时访问共享资源的线程数量。当一个线程进入临界区时，它会尝试获取信号量，如果信号量的值大于 0，则表示资源可用，线程可以继续执行；如果信号量的值等于 0，则表示资源不可用，线程会被阻塞，直到资源可用。

**特点：**

- 信号量是一种整数型变量，可以有多种取值。
- 信号量可以用于解决生产者-消费者问题、限流等场景。
- 信号量可以是二进制信号量（取值为 0 或 1）或计数信号量（取值大于等于 0）。

#### 3. 条件变量（Condition Variable）：

**概念：** 条件变量是一种线程间的通信机制，用于在多线程环境中实现线程的等待和唤醒操作。条件变量通常与互斥锁配合使用，等待线程在条件不满足时会阻塞，并释放互斥锁；当条件满足时，唤醒线程并重新获取互斥锁，继续执行。

**特点：**

- 条件变量用于解决线程间的同步和通信问题，允许线程在特定条件下等待或唤醒。
- 条件变量通常与互斥锁一起使用，互斥锁用于保护条件变量的访问和修改。



### TCP与UDP有什么区别，各有什么优劣？

TCP（传输控制协议）和UDP（用户数据报协议）是两种不同的传输层协议，用于在计算机网络中传输数据。它们之间的主要差异包括：

1. **连接性**：
   - TCP 是面向连接的协议，它在通信之前需要建立连接，然后在通信结束时释放连接。这种连接方式保证了数据的可靠性和顺序性。
   - UDP 是无连接的协议，通信双方在发送数据之前不需要建立连接，也不需要维护连接状态。因此，UDP 的通信速度通常比 TCP 快，但不具备 TCP 那种可靠性和顺序性。
2. **可靠性**：
   - TCP 提供可靠的数据传输。它通过序号、确认和重传机制来确保数据的可靠性，即使在网络出现丢包或者出现延迟的情况下，也能够保证数据的完整性和顺序性。
   - UDP 不提供可靠的数据传输保证。它仅仅提供了数据的最基本的传输功能，不对数据进行确认和重传，因此在网络不可靠或者对实时性要求较高的情况下使用。
3. **头部开销**：
   - TCP 的头部开销相对较大，因为它需要包含序号、确认号、窗口大小等控制信息，以及可选的选项字段。
   - UDP 的头部开销较小，只包含了源端口、目标端口、长度和校验和等基本信息，因此 UDP 的头部开销比 TCP 小。
4. **适用场景**：
   - TCP 适用于对数据传输可靠性要求较高的场景，如文件传输、网页浏览、电子邮件等。
   - UDP 适用于实时性要求较高，且对数据可靠性要求不高的场景，如音视频流媒体、在线游戏等。

**TCP优点：**

- 可靠性高，适用于对数据传输可靠性要求较高的场景，如文件传输、网页浏览等。

**TCP缺点：**

- 建立连接和断开连接的开销较大，影响了数据传输的实时性。
- 数据传输的实时性较差，不适用于对实时性要求较高的场景，如实时视频传输、游戏等。

**UDP优点：**

- 建立连接和断开连接的开销小，适用于对数据传输实时性要求较高的场景，如实时音频传输、视频会议等。
- 数据传输的实时性好，不受连接建立和断开的影响。

**UDP缺点：**

- 不可靠性高，数据传输可能会丢失或乱序，需要应用层进行数据重传和确认。
- 不提供流量控制机制，容易导致网络拥塞，影响数据传输的稳定性。

#### TCP为什么要经历三次握手

1. **确认双方能够正常收发数据：** 第一次握手中，客户端向服务器发送连接请求报文段，服务器收到后进行确认，并进入 SYN-RCVD 状态；第二次握手中，服务器向客户端发送连接确认报文段，客户端收到后也进入 ESTABLISHED 状态；第三次握手中，客户端向服务器发送确认报文段，服务器收到后也进入 ESTABLISHED 状态。通过这个过程，确保了双方都能够正常收发数据。
2. **防止已失效的连接请求报文段被服务端误认为是新的连接请求：** 如果只进行两次握手，那么在某些情况下，客户端发送的连接请求报文段可能会在网络中被延迟，导致服务端收到后进行确认，但客户端并未收到确认，此时客户端会认为连接未建立成功，并重新发送连接请求。而服务端可能会收到之前已经确认过的连接请求报文段，并错误地认为是新的连接请求。因此，通过第三次握手，可以避免这种情况发生，确保已失效的连接请求报文段不会被误认为是新的连接请求。
3. **确保连接的可靠性：** 三次握手过程中，客户端和服务端都有机会确认对方的身份和能力，并且在第三次握手中，客户端和服务端都对连接进行了确认，从而确保了连接的可靠性和稳定性。



### TCP的四次挥手过程

终止一个已建立的 TCP 连接。这个过程涉及到两端（客户端和服务器端）互相发送控制信息以关闭连接。

1. 第一次挥手：客户端向服务器端发送一个 TCP 报文段，设置 FIN 标志位，表示客户端已经没有数据要发送了，但仍然可以接收数据。客户端进入 FIN_WAIT_1 状态，等待服务器端的确认。
2. 第二次挥手：服务器端收到客户端发送的 FIN 报文段后，会发送一个 ACK 报文段作为确认。此时服务器端进入 CLOSE_WAIT 状态，表示已经收到了客户端的关闭请求，但服务器端还有数据需要发送给客户端。
3. 第三次挥手：当服务器端确定数据都发送完毕后，会向客户端发送一个 FIN 报文段，表示服务器端已经没有数据要发送了。服务器端进入 LAST_ACK 状态。
4. 第四次挥手：客户端收到服务器端发送的 FIN 报文段后，客户端会发送一个 ACK 报文段作为确认。客户端进入 TIME_WAIT 状态，等待可能出现的延迟报文。



### 介绍虚继承

虚继承的主要作用是解决由多重继承导致的菱形继承（Diamond Inheritance）问题。在多重继承中，如果一个类同时继承自两个或多个具有共同基类的类，而这些共同基类又有一个共同的派生类，就会形成菱形继承的结构。这样的继承结构可能会导致问题，例如数据成员在派生类中出现多次，导致冗余或不一致性。**虚继承通过在派生类对共同基类进行虚继承来解决这个问题。使用虚继承后，共同基类在继承体系中只会被派生类保留一份**

```C++
class Base {
public:
    int data;
};

class Derived1 : virtual public Base {
    // Derived1 可以通过 Base 继承的 data
};

class Derived2 : virtual public Base {
    // Derived2 可以通过 Base 继承的 data
};

class FinalDerived : public Derived1, public Derived2 {
    // 可以直接访问 Base 继承的 data，而不会有二义性
};
```

### C++的结构体内存对齐

尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度。32位系统处理器只能从地址为4的倍数的内存开始读取数据。内存对齐的目的是为了提高内存访问的效率，减少内存访问的次数，以及避免因为非对齐内存访问而引起的性能损失。

C++ 中结构体的内存对齐规则如下：

1. 结构体的每个成员变量的起始地址必须是其自身大小的整数倍。
2. 结构体的大小必须是其最大成员大小的整数倍。

### Linux常用命令

`ls`: 列出当前目录的内容。

`ls -l`: 以长格式列出当前目录的内容，包括文件权限、所有者、大小等信息。

`ls -a`: 列出当前目录的所有内容，包括隐藏文件。

`pwd`: 显示当前工作目录的完整路径。

`rm -f`: 强制删除，不提示确认。

`rm -r`: 递归删除目录及其内容。

`rmdir`: 删除一个空目录。

`cp -r`: 递归复制目录及其内容。

`cat`: 查看文件内容。

`more` 或 `less`: 分页查看文件内容，可以滚动查看大文件。

`nano` 或 `vi` 或 `vim`: 编辑文件的内容。

`chmod`: 改变文件或目录的权限。

```Ba
-R：递归地修改目录及其下属文件和子目录的权限。
符号：+ 表示添加权限，- 表示删除权限，= 表示设置权限。
权限：r 表示读权限，w 表示写权限，x 表示执行权限。
用户类型：u 表示所有者，g 表示所属组，o 表示其他用户，a 表示所有用户。
chmod u+x file.txt：给文件的所有者添加执行权限。
chmod a=rwx directory：设置目录的所有用户都具有读、写、执行权限。
```

`find`: 在指定目录中搜索文件。

```bash
find 路径 [选项] [表达式]
-name 模式：按照文件名模式进行搜索，模式可以使用通配符。
-type 类型：指定要搜索的文件类型，如 f 表示普通文件，d 表示目录。
-size 大小：按照文件大小进行搜索，可以使用 + 表示大于，- 表示小于，以及 c 表示字节、k 表示千字节、M 表示兆字节等单位。
-mtime +n/-n：按照修改时间进行搜索，+n 表示修改时间在 n 天之前，-n 表示修改时间在 n 天之内。
find /path/to/search -type d -mtime -7 -exec ls -ld {} \;：搜索指定目录下最近 7 天内修改过的目录，并输出详细信息。
```

**linux如何查看某个文件的第几列：**

**linux如何查看某个文件有多少行：**



### git命令

1. `git add .`：将当前目录下的所有修改或新增的文件添加到暂存区。

2. `git commit -m ""`：将暂存区中的文件提交到本地仓库，并附上一条提交说明。

3. `git push`：将本地仓库中的提交推送到远程仓库。

4. `git pull`：从远程仓库获取最新的版本并合并到本地仓库。

5. `git log`：查看提交日志，显示提交历史记录。

6. `git status`：查看当前工作目录状态，显示有关文件的状态信息。

7. `git merge`：将其他分支的修改合并到当前分支。

   git merge <branch-to-merge>

   如果在合并过程中发生冲突（即两个分支上的更改相互冲突），Git 将会暂停合并并将冲突标记在文件中。在这种情况下，你需要手动解决冲突，然后执行 `git merge --continue` 来完成合并。

8. `git checkout`：用于切换分支或恢复文件。

9. `git clone`：从远程仓库克隆项目到本地。

10. `git revert`：撤销某次提交的修改，但会创建一个新的提交来记录撤销操作。

    例如，`git revert <commit>` 将创建一个新的提交，来撤销指定的 `<commit>` 的更改。

11. `git reset` 可以将当前分支的 HEAD 移动到指定的提交或分支，同时将工作目录和暂存区的内容回滚到指定的状态。它有不同的模式：

    `git reset --soft <commit>`: 保留工作目录和暂存区不变，只移动 HEAD 到指定提交。

    `git reset --mixed <commit>` (默认行为): 移动 HEAD 到指定提交，并重置暂存区，但保留工作目录不变。

    `git reset --hard <commit>`: 移动 HEAD 到指定提交，并重置暂存区和工作目录，使其与指定提交完全一致。



### scp和cp的区别

`scp`和`cp`都是用于文件复制的命令，但它们之间有几个重要的区别：

1. **scp**：是基于SSH协议的安全文件传输工具。用于在本地计算机和远程计算机之间传输文件，可以跨越网络进行文件复制。通过加密传输数据，提供了更高的安全性，适用于在不可信的网络环境中传输文件。
2. **cp**：是Linux/Unix系统中用于复制文件和目录的标准命令。用于在本地文件系统内复制文件，不能直接跨越网络进行文件复制。在本地计算机上复制文件，不涉及网络传输，因此通常比`scp`更快。



### 深度优先遍历和广度优先遍历

#### 广度优先搜索（BFS）：

- **原理**：BFS从图中的某个起始节点开始，首先遍历起始节点的所有邻居节点，然后再依次遍历邻居节点的邻居节点，以此类推，直到遍历完整个图为止。它按层级的顺序逐层遍历，先访问距离起始节点最近的节点。
- **数据结构**：通常使用队列（Queue）来实现BFS，起始节点入队，然后出队时将其邻居节点入队，依次进行。
- **应用**：BFS常用于寻找最短路径、查找图的连通性、生成迷宫等。

#### 深度优先搜索（DFS）：

- **原理**：DFS从图中的某个起始节点开始，首先遍历起始节点的一个邻居节点，然后再以同样的方式遍历该邻居节点的一个邻居节点，依次进行直到到达最深的节点，然后再回溯到前面的节点，以同样的方式遍历其他未被访问过的邻居节点，直到所有节点都被访问过。
- **数据结构**：通常使用递归或者栈（Stack）来实现DFS。递归方式下，函数自己调用自己，栈方式下，手动维护一个栈来保存节点。
- **应用**：DFS常用于图的遍历、拓扑排序、寻找连通分量、解决迷宫问题等。

### 区别：

1. **访问顺序**：BFS按层级顺序遍历，先访问离起始节点最近的节点；DFS先遍历当前节点的一个分支，直到末端再回溯到前面的节点继续搜索其他分支。
2. **数据结构**：BFS通常使用队列，而DFS通常使用递归或者栈。
3. **空间复杂度**：BFS在存储未访问节点时需要较大的空间，因为它需要将所有的当前层节点都存储起来，而DFS则不需要这样做，因此在空间上DFS比BFS更节省。
4. **时间复杂度**：在相同的条件下，BFS和DFS的时间复杂度一样，都是 O*(*V*+*E)，其中V是节点数，E 是边数。
5. **应用场景**：具体应用场景不同。BFS适用于解决最短路径等问题，而DFS适用于拓扑排序、连通分量等问题。



### C++如何做多线程

```C++
#include <iostream>
#include <thread>

// 线程函数
void threadFunction(int threadID) {
    std::cout << "Thread " << threadID << " is running." << std::endl;
}

int main() {
    // 创建并启动多个线程
    std::thread t1(threadFunction, 1);
    std::thread t2(threadFunction, 2);

    // 主线程继续执行其他工作
    std::cout << "Main thread is running." << std::endl;

    // 等待线程执行完毕
    t1.join();
    t2.join();

    // 所有线程执行完毕后，程序结束
    std::cout << "All threads have finished." << std::endl;

    return 0;
}
```

### C++线程和协程的概念

#### 线程：

线程是操作系统调度的基本单位，是程序中独立执行的一段代码。

1. 每个线程都有自己的执行上下文，包括堆栈、寄存器和程序计数器。
2. 线程之间共享进程的内存空间，可以直接访问共享的全局变量和数据。
3. 多线程可以实现并发执行，提高程序的响应性和性能。

C++11 引入了 `std::thread` 类，用于创建和管理线程。通过 `std::thread` 类，可以创建新的线程，并将函数或可调用对象作为线程的入口点。

#### 协程：

协程是一种轻量级的线程，是由程序控制的执行单元，可以在执行过程中暂停和恢复。

1. 协程不依赖于操作系统的线程调度，而是由程序显式控制。
2. 协程之间可以实现协作式的调度，而不是竞争式的调度。
3. 协程可以通过暂停和恢复的操作来避免线程切换的开销，提高程序的效率。
4. C++20 引入了协程（Coroutines）的支持，通过 `co_await`、`co_yield` 等关键字来实现协程。协程的主要特点是可以在函数内部保存状态，并在之后恢复执行，而不需要重新创建新的线程。这使得协程在编写异步代码和状态机等场景下非常有用。

### 为什么要有协程

在并发编程中，协程允许在单个线程内执行多个独立的函数，并且这些函数之间可以暂停和恢复执行，以实现非抢占式的多任务处理。相比于线程和进程，协程的创建和切换成本更低。在异步编程中，协程可以用于编写高效且清晰的非阻塞代码。



### C++垃圾回收机制

C++标准库中并没有提供内置的垃圾回收机制，依赖于手动管理内存。但是现代C++中可以采用如下方法：

1. **智能指针（Smart Pointers）**：C++11引入了智能指针（如`std::shared_ptr`、`std::unique_ptr`、`std::weak_ptr`），它们可以自动管理资源的生命周期，避免了手动管理内存的一些问题，如内存泄漏和悬挂指针。
2. **RAII（Resource Acquisition Is Initialization）**：RAII是一种C++编程技术，它利用对象生命周期与资源的关系来管理资源，通过在对象构造函数中获取资源，析构函数中释放资源，从而确保资源的正确管理。RAII可用于管理任何资源，不仅限于内存。
3. **智能容器（Smart Containers）**：除了智能指针外，还有一些智能容器（如`std::vector`、`std::string`等）可以自动管理动态分配的内存，并提供了更安全和方便的内存管理方式。
4. **垃圾收集库**：虽然C++标准库本身没有提供垃圾回收机制，但可以使用第三方库来实现垃圾收集。例如，有一些开源的C++垃圾收集库（如Boehm GC、Libgc等），可以用于在C++中实现垃圾回收。



### 详细讲讲智能指针

智能指针是C++标准库提供的一种智能内存管理工具，用于管理动态分配的内存资源，自动进行内存分配和释放，从而避免了手动管理内存带来的一系列问题，如内存泄漏、野指针等。C++11引入了三种主要的智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`。

1. std::unique_ptr:`std::unique_ptr`是一种独占所有权的智能指针，每个指针都独占管理一个对象，不能被复制，但可以被移动。当`std::unique_ptr`超出作用域时，它所管理的资源会被自动释放。

   ```C++
   #include <memory>
   
   int main() {
       std::unique_ptr<int> ptr(new int(5)); // 创建一个指向int类型的独占智能指针
       return 0; // 在main函数结束时，ptr超出作用域，所管理的内存会被自动释放
   }
   ```

2. std::shared_ptr:`std::shared_ptr`是一种共享所有权的智能指针，多个指针可以共同管理一个对象，通过引用计数来跟踪对象的生命周期。当最后一个`std::shared_ptr`指针超出作用域时，它所管理的资源会被释放。

   ```C++
   #include <memory>
   
   int main() {
       std::shared_ptr<int> ptr1(new int(5)); // 创建一个指向int类型的共享智能指针
       std::shared_ptr<int> ptr2 = ptr1; // 多个共享指针指向同一资源
       return 0; // 在main函数结束时，ptr1和ptr2超出作用域，所管理的内存会被自动释放
   }
   ```

3. std::weak_ptr:`std::weak_ptr`是`std::shared_ptr`的一种辅助智能指针，它不会增加引用计数，不会影响对象的生命周期。主要用于解决`std::shared_ptr`循环引用导致的内存泄漏问题。

### 智能指针优缺点

**优点：**1. 自动内存管理，自动管理内存的分配和释放，无需程序员手动释放内存。这减少了内存泄漏的可能性，并提高了程序的健壮性和稳定性。2. 支持多线程安全： `std::shared_ptr`提供了多线程安全的内存管理机制，可以在多线程环境下安全地共享资源。

**缺点：**1.性能开销，智能指针可能会引入一定的性能开销，包括内存分配和释放的额外开销，以及引用计数等机制的运行开销。2.  `std::shared_ptr`可能会出现循环引用的问题，导致资源无法正确释放，从而引发内存泄漏。



### 防止内存泄漏的方法 

内存泄漏是指程序在动态分配内存后，没有释放该内存，导致该内存不能再次被使用，从而造成系统的内存资源浪费。下面是一些防止内存泄漏的方法：

1. **使用智能指针**：
   - 使用智能指针（如`std::unique_ptr`和`std::shared_ptr`）来管理动态分配的内存。这些智能指针可以自动管理资源的生命周期，当指针超出作用域时，会自动释放内存，从而避免了手动释放内存时可能遗漏的问题。
2. **使用 RAII（资源获取即初始化）原则**：
   - 在类的构造函数中分配资源，在析构函数中释放资源。这样可以确保资源在对象生命周期结束时被正确释放，即使在发生异常或者其他错误的情况下也能够正常释放资源。
3. **避免动态分配内存**：
   - 在可能的情况下，尽量避免使用`new`和`delete`进行动态内存分配和释放。可以考虑使用栈上分配的对象或者使用标准库容器来管理对象。



### 如何判定是否离开了作用域

1. **变量的生命周期**：在程序中，每个变量都有其生命周期，即它在程序执行期间存在的时间段。当变量所在的作用域结束时，该变量的生命周期也就结束了。因此，可以通过观察变量的声明位置和其所在的代码块范围来确定变量是否离开了作用域。
2. **变量的析构函数调用**：如果一个对象具有析构函数，在对象离开作用域时，其析构函数将被自动调用。因此，可以通过观察对象的析构函数是否被调用来判断对象是否已经离开了作用域。
3. **智能指针的生命周期**：如果一个对象被智能指针管理，可以通过观察智能指针的生命周期来确定对象是否离开了作用域。当智能指针离开作用域时，它所管理的对象也会被销毁。



### C++内部如何存储复数和浮点数

1. 浮点数（Floating-point numbers）：

- **单精度浮点数（float）**：占用4个字节（32位），由1位符号位、8位指数位和23位尾数位组成。
- **双精度浮点数（double）**：占用8个字节（64位），由1位符号位、11位指数位和52位尾数位组成。

浮点数使用科学计数法来表示，其内部存储格式为：符号位 * 尾数 * (2 ^ 指数)。

2. 复数（Complex numbers）：

C++标准库提供了`std::complex`模板类用于表示复数。复数由实部和虚部组成，分别是浮点数类型。通常实部和虚部可以是`float`、`double`或者`long double`类型。这些类型的存储方式与上述描述的浮点数存储方式相同。



### vector resize和reserve区别

在C++中，`vector`是一个动态数组容器，它可以根据需要动态调整大小以容纳更多的元素。

```C++
// 增加了容器的大小，新元素将被默认初始化。
// 减少了容器的大小，超出新大小的元素将被销毁。
// 可能会导致重新分配内存，因此在调用时会影响到容器的性能
vec.resize(10); // 将vec的大小调整为10
```

```C++
// 用于分配内存以容纳至少指定数量的元素，但不会改变容器中元素的数量。
// 不会初始化新元素，它只是分配足够的内存以容纳后续添加的元素
// 不会影响容器的大小，只是预留了足够的内存空间。
vec.reserve(10); // 为至少 10 个元素分配内存
```



### 缓存命中率

缓存命中率是衡量计算系统中缓存效率的指标之一。它表示在对缓存进行访问时，所获取到的数据在缓存中已经存在的比率。

1. 合理的缓存大小：缓存大小不宜太小，以免无法存储足够多的数据；也不宜太大，以免造成资源浪费。
2. 缓存替换策略：选择合适的替换策略，如最近最少使用（LRU）、先进先出（FIFO）等，以确保缓存中存储的是最有可能被再次访问的数据。
3. 数据局部性：利用空间局部性和时间局部性原理，预测未来可能被访问的数据，并将其缓存起来。
4. 数据预取：根据程序访存的规律，提前将可能被使用的数据加载到缓存中。



### 红黑树

红黑树（Red-Black Tree）是一种**自平衡的二叉查找树**（二叉查找树，左子树的所有值小于根节点，右子树的所有值均大于根节点的值），它保持了良好的平衡性，以确保在最坏情况下的**时间复杂度为 O(log n)**，其中 n 是树中节点的数量。

红黑树的特点：1. 节点是红色或者黑色；2. 根节点是黑色；3. 所有叶子节点都是黑色（nullptr）；4.每个红色节点必须有两个黑色的子节点；5.从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。

![An example of a red-black tree](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

优点： 1. 红黑树通过节点的颜色属性来保证了它的自平衡性，确保了树的高度保持在较小的范围内（约为 log(N)），从而保持了快速的查找、插入和删除操作的时间复杂度为 O(logN)。2. 红黑树的自平衡性保证了在执行插入和删除操作后，树的结构会保持平衡，不会出现极端不平衡的情况。

缺点：1. 红黑树的插入和删除操作相对复杂，需要对树的结构进行调整和平衡，这增加了实现的复杂性。2. 红黑树中每个节点需要额外存储颜色信息，这增加了树的空间开销。



### 哈希表的原理

通过哈希函数将键映射到存储桶（Bucket）中，从而实现快速的插入、查找和删除操作。

**hash函数：**将键（Key）映射到哈希表中的索引（Index），这个索引称为哈希值（Hash Value）或哈希码（Hash Code）。

**存储桶：**哈希表通常由一个固定大小的数组（Bucket Array）组成，每个数组元素称为一个存储桶，用于存储键值对。当多个键映射到同一个索引时，它们会被存储在同一个存储桶中。

**处理冲突：**1. 链地址法：每个存储桶存储一个链表或其他数据结构，用于存储冲突的键值对。2.开放地址法：当发生冲突时，通过一定的规则寻找下一个可用的存储位置。

**插入：**插入操作首先使用哈希函数计算键的哈希值，然后确定存储位置。如果存储位置已经被占用，根据冲突解决策略选择下一个可用位置，直到找到一个空闲的位置。

**查找：**首先使用哈希函数计算键的哈希值，然后确定存储位置。如果存储位置为空，则说明键不存在。如果存储位置被占用，根据冲突解决策略，检查存储位置中的键是否与待查找的键匹配

**删除：**首先定位到存储位置。如果存储位置为空，则不需要进行任何操作。如果存储位置被占用，根据冲突解决策略，找到匹配的键，并将其删除。



### map 和 unordered map区别，空间很多时间很紧，选择哪一个

1. `map` 是基于**红黑树**实现的，因此它的查找、插入和删除操作的时间复杂度是 O(log n).

   优点： 有序性，这是map结构最大的优点；

   缺点：空间占用率高，因为map内部实现了红黑树；

   适用于那些有顺序要求的问题，用map会更高效一些

2. `unordered_map` 是基于**哈希表**实现的，它的查找、插入和删除操作的平均时间复杂度是 O(1)；

   优点：内部实现了哈希表，因此其查找速度非常的快

   缺点：哈希表的建立比较耗费时间

   适用于：对于查找问题，unordered_map会更加高效一些



#### map里面[]和at有什么区别

`[]` 运算符不进行边界检查。如果尝试访问一个不存在的键，则会创建一个具有该键的新元素，并将其值默认初始化

`at()` 方法进行边界检查。如果尝试访问一个不存在的键，则会抛出 `std::out_of_range` 异常。



### malloc申请存储的空间有办法释放吗

```C++
#include <stdlib.h>

int main() {
    // 使用malloc分配内存
    int* ptr = (int*)malloc(sizeof(int) * 10);
    
    if (ptr == NULL) {
        // 内存分配失败
        exit(1);
    }
    
    // 使用内存空间...
    
    // 释放内存空间
    free(ptr);
    
    return 0;
}

```



### new和malloc的区别

`new`和`malloc`都是用于在堆（heap）上分配内存的C++操作符和函数，但它们有几个重要的区别：

1. **返回类型**：
   - `new`是C++中的操作符，返回的是分配类型的指针。
   - `malloc`是C标准库中的函数，返回的是`void*`指针，需要进行类型转换后才能使用。
2. **类型安全性**：
   - `new`是类型安全的，它会自动计算要分配的内存空间的大小，并将指针转换为正确的类型。
   - `malloc`不是类型安全的，需要手动计算要分配的内存空间的大小，并进行类型转换。
3. **构造函数的调用**：
   - 使用`new`分配的内存空间会调用对象的构造函数进行初始化。
   - 使用`malloc`分配的内存空间不会调用对象的构造函数，需要手动调用构造函数进行初始化。
4. **对数组的处理**：
   - `new`可以直接分配数组，并使用`delete[]`来释放数组。
   - `malloc`只能分配单个内存块，并使用`free`来释放内存，对于数组需要手动计算空间大小和释放内存。
5. **异常处理**：
   - `new`在分配内存失败时会抛出`std::bad_alloc`异常，需要使用`try-catch`块来捕获异常。
   - `malloc`在分配内存失败时返回`NULL`指针，需要手动检查返回值来处理分配失败的情况。



### 零拷贝

零拷贝（Zero-copy）是一种优化技术，旨在减少数据在系统中的复制次数，从而提高数据传输的效率和性能。在传统的数据传输过程中，数据通常需要在应用程序的用户空间和内核空间之间进行多次复制，而零拷贝技术可以通过在不同层次上优化数据传输过程来减少这种复制。

1. **用户空间到内核空间的零拷贝**：传统上，当应用程序需要将数据从用户空间传输到内核空间时，数据通常需要通过系统调用来复制到内核缓冲区中。而使用零拷贝技术，应用程序可以直接将数据的指针传递给系统调用，而无需实际复制数据，从而避免了一次复制。
2. **内核空间到内核空间的零拷贝**：在一些情况下，数据在内核空间之间传输时也可能会发生复制。零拷贝技术可以通过使用共享内存区域或直接DMA（直接内存访问）等技术，避免数据在内核空间之间的复制。
3. **内核空间到用户空间的零拷贝**：类似地，当数据需要从内核空间传输到用户空间时，零拷贝技术可以避免额外的数据复制。例如，内核可以直接将数据发送到应用程序的用户空间缓冲区，而无需额外复制数据。



### 什么是namespace

在C++中，namespace（命名空间）是一种组织代码和避免命名冲突的机制。它允许开发人员将一系列相关的变量、函数和类封装在一个独立的作用域中。通过使用命名空间，可以有效地组织大型项目的代码，并且可以更轻松地与其他库和代码集成而不会发生名称冲突。

命名空间的主要目的之一是避免命名冲突。当在不同的库或模块中使用相同名称时，命名空间可以确保它们不会相互干扰。



### python的threading和pyqt的有什么区别

1. 线程模型：

   Python 的 threading 模块提供了多线程编程的基本支持，使用标准的线程模型。它允许创建和管理线程，但在 Python 中由于全局解释器锁（GIL）的存在，多线程并不能实现真正的并行执行，而是通过线程间的切换来模拟并发。

   PyQt 也提供了多线程编程的支持，但它是基于 Qt 库提供的线程模型的。Qt 的线程模型是基于事件循环的，通过将耗时操作放在单独的线程中执行，以保持主线程的响应性。PyQt 的多线程功能通常与信号槽机制结合使用，以便在不同线程之间进行通信和同步。

2. 事件循环：

   在 threading 模块中，Python 的线程是基于操作系统的线程实现的，没有事件循环的概念，线程的执行由操作系统调度。

   在 PyQt 中，每个线程都有自己的事件循环。主线程的事件循环通常由 Qt 主循环负责，而子线程的事件循环需要手动启动和管理。

3. 线程通信：

   在 threading 模块中，线程之间的通信可以通过共享变量、锁、条件变量等机制实现。

   在 PyQt 中，线程之间的通信通常使用信号槽机制。



### 对python的修饰器有什么理解

用于在函数或类的定义前面添加一个修饰器，以实现对函数或类的装饰或修改。

`@torch.no_grad()`: 在装饰器内部，它定义了一个内部函数 `wrapper`，该函数使用 `with torch.no_grad():` 上下文管理器来包裹被修饰的函数 `func` 的调用。在进入 `torch.no_grad()` 上下文管理器的代码块时，会调用 `torch.set_grad_enabled(False)`，该函数会设置梯度跟踪的开关为关闭状态。在退出上下文管理器的代码块时，会调用 `torch.set_grad_enabled(True)` 来恢复梯度跟踪的开关状态。

```python
def no_grad(func):
    def wrapper(*args, **kwargs):
        with torch.no_grad():
            return func(*args, **kwargs)
    return wrapper

@no_grad
def inference(model, input_data):
    output = model(input_data)
    return output
```

`@staticmethod`：用于声明静态方法。

`@classmethod`：用于声明类方法。

`@property`：将一个方法转化为只读属性。

1. 类方法（classmethod）和静态方法（staticmethod）都是类级别的方法。
2. 类方法的第一个参数是 `cls`，表示类本身，可以用来访问类的属性和方法。静态方法没有特殊的参数，与普通的函数一样。类方法通过 `cls` 参数可以访问和操作类的属性和方法，因此可以被子类继承和覆盖。静态方法与类的状态无关，因此无法通过继承来改变其行为。
3. 类方法可以访问和修改类的状态（类变量），并且可以调用其他类方法。静态方法不能直接访问类变量或者调用其他类方法，因为它们与类的状态无关。



### Python 的基本数据类型？

Python 的语言类型定义是**强类型**的**动态语言**。

- 强类型和弱类型指的是是否会发生类型的隐式转换；
- 动态语言还是静态语言指的是编译期还是运行期确定类型；

Python 中变量一旦确定类型，如果在之后的代码中赋值给此变量其他类型是可以的。

```python
# 下面的转换是不允许的，但这在弱类型的 Javascript 中是允许的
foo = 'abc'
abc = 123
print(foo + abc)
```

Python 变量的类型是在运行期间才确定的，因此 Python 属于动态语言，这有别与 Java，Java 在变量声明时就必须指定变量的类型。



- Number（数字）(包括整型、浮点型、复数、布尔型等)
- String（字符串）
- List（列表）
- Tuple（元组），不可变数据
- Set（集合）
- Dictionary（字典）



### Python 中的 `*args` 和 `**kwargs` 表示什么？

`*args`：它允许函数接受任意数量的位置参数。这意味着你可以在调用函数时传递任意数量的位置参数，而不需要预先指定它们的数量。

`**kwargs`：它允许函数接受任意数量的关键字参数。

```python
def my_function(*args, **kwargs):
    for arg in args:
        print(arg)
    for key, value in kwargs.items():
        print(f"{key}: {value}")

my_function(1, 2, 3, name="Alice", age=30)  # 输出: 1 2 3  name: Alice  age: 30
```



### Python 语法中 “==” 和 “is” 的区别是什么？

`==` 运算符用于比较两个对象的值是否相等。

`is` 运算符用于比较两个对象的身份（内存地址）是否相同。



### Python 中为什么没有函数重载？

Python是一种动态类型语言，变量的类型是在运行时确定的，而不是在编译时确定的。由于函数参数的类型是动态的，因此编译器无法在编译时根据参数类型来确定调用哪一个函数。

在Python中，函数的多态性是通过鸭子类型（duck typing）来实现的，即不关心对象的具体类型，只关心对象是否具有特定的方法或行为。因此，不需要函数重载来处理不同类型的参数，只需确保传递的对象能够正确地响应函数调用即可。



### 介绍用过 Python 标准库中的哪些模块？

##### os模块

**文件操作：**

- `os.getcwd()`: 获取当前工作目录的路径。
- `os.chdir(path)`: 改变当前工作目录到指定路径。
- `os.listdir(path='.')`: 返回指定目录下的所有文件和目录的列表。
- `os.mkdir(path)`: 创建新目录。
- `os.makedirs(path)`: 递归创建多级目录。
- `os.remove(path)`: 删除指定路径的文件。
- `os.rmdir(path)`: 删除指定路径的目录（只能删除空目录）。
- `os.removedirs(path)`: 递归删除多级目录。
- `os.rename(src, dst)`: 重命名文件或目录。
- `os.path.exists(path)`: 判断指定路径是否存在。

**环境变量操作：**

- `os.environ`: 返回一个包含环境变量的字典。

**系统信息：**

- `os.name`: 返回操作系统名称，`posix` 表示 Linux、Unix 或 macOS，`nt` 表示 Windows。
- `os.uname()`: 返回包含系统信息的元组（仅在 Unix/Linux 系统中可用）。
- `os.system(command)`: 执行系统命令。

**路径操作：**

- `os.path.join(path1, path2, ... )`: 将多个路径组合成一个路径。
- `os.path.abspath(path)`: 返回指定路径的绝对路径。
- `os.path.basename(path)`: 返回指定路径的基名（文件名或最后一级目录名）。
- `os.path.dirname(path)`: 返回指定路径的目录名

#### logging

- `logging.getLogger(name)`: 获取一个名为 `name` 的日志记录器对象，如果不指定 `name`，则返回根日志记录器对象。
- `logger.setLevel(level)`: 设置日志记录器的日志级别，只有级别高于或等于指定级别的日志才会被记录。
- `logger.addHandler(handler)`: 添加一个处理程序到日志记录器。
- `logger.removeHandler(handler)`: 从日志记录器中移除指定的处理程序。
- `logger.debug(msg, *args, **kwargs)`: 记录调试级别的日志消息。
- `logger.info(msg, *args, **kwargs)`: 记录信息级别的日志消息。
- `logger.warning(msg, *args, **kwargs)`: 记录警告级别的日志消息。
- `logger.error(msg, *args, **kwargs)`: 记录错误级别的日志消息。
- `logger.critical(msg, *args, **kwargs)`: 记录严重错误级别的日志消息。

### 什么是鸭子类型（duck typing）？

鸭子类型（duck typing）是一种动态类型语言中的编程风格，其核心思想是“如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子”。换句话说，鸭子类型关注的是对象的行为（具有特定的方法或属性），而不是对象的类型。

在 Python 语言中，有很多 bytes-like 对象（如：bytes、bytearray、array.array、memoryview）、file-like 对象（如：StringIO、BytesIO、GzipFile、socket）、path-like对象（如：str、bytes）。

- 其中 file-like 对象都能支持 read 和 write 操作，可以像文件一样读写，这就是所谓的对象有鸭子的行为就可以判定为鸭子的判定方法。
- 再比如 Python 中列表的 extend 方法，它需要的参数并不一定要是列表，只要是可迭代对象就没有问题。



### 什么是 Lambda 函数？

Lambda 函数也叫匿名函数，它是功能简单用一行代码就能实现的小型函数。Python 中的 Lambda 函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写 return 关键字。

```python
items = [12, 5, 7, 10, 8, 19]
items = list(map(lambda x: x ** 2, filter(lambda x: x % 2, items)))
print(items)    # [25, 49, 361]
```



### 正则表达式的 match 方法和 search 方法有什么区别？

`match()` 方法从字符串的开头开始匹配模式，如果字符串的开头匹配成功，则返回匹配对象；如果字符串的开头不匹配，则返回 `None`。即 `match()` 方法只匹配字符串的开头部分。

`search()` 方法在整个字符串中搜索匹配的模式，如果找到了匹配的子串，则返回匹配对象；如果找不到匹配的子串，则返回 `None`。即 `search()` 方法会在整个字符串中搜索，而不仅仅是从开头开始。

```python
import re
text = "The cat sat on the mat."
# 使用 match() 方法
match_result = re.match(r'cat', text)  # match_result=None

# 使用 search() 方法
search_result = re.search(r'cat', text) # search_result.group()="cat"
```



### 什么是 Python 中的魔术方法？

| 魔术函数                                                     | 作用               |
| ------------------------------------------------------------ | ------------------ |
| `__new__`、`__init__`、`__del__`                             | 创建和销毁对象相关 |
| `__eq__`、`__ne__`、`__lt__`、`__gt__`、`__le__`、`__ge__`   | 关系运算符相关     |
| `__pos__`、`__neg__`、`__invert__`                           | 一元运算符相关     |
| `__lshift__`、`__rshift__`、`__and__`、`__or__`、`__xor__`   | 位运算相关         |
| `__enter__`、`__exit__`                                      | 上下文管理器协议   |
| `__iter__`、`__next__`、`__reversed__`                       | 迭代器协议         |
| `__int__`、`__long__`、`__float__`、`__oct__`、`__hex__`     | 类型/进制转换相关  |
| `__str__`、`__repr__`、`__hash__`、`__dir__`                 | 对象表述相关       |
| `__len__`、`__getitem__`、`__setitem__`、`__contains__`、`__missing__` | 序列相关           |
| `__add__`、`__sub__`、`__mul__`、`__div__`、`__floordiv__`、`__mod__` | 算术运算符相关     |



### 说一下你对 Python 中模块和包的理解？

每个 Python 文件就是一个模块，而保存这些文件的文件夹就是一个包，但是这个作为 Python 包的文件夹必须要有一个名为 `__init__.py` 的文件，否则无法导入这个包。

模块和包解决了 Python 中命名冲突的问题，不同的包下可以有同名的模块，不同的模块下可以有同名的变量、函数或类。



### 什么情况下会出现 `KeyError`、`TypeError`、`ValueError`？

通过一个字典 a，执行 `int(a['x'])` 这个操作就有可能引发上述三种类型的异常。

- 如果字典中没有键 x，会引发 KeyError；

- 如果键 x 对应的值不是 str、float、int、bool 以及 bytes-like 类型，在调用 int 函数构造 int 类型的对象时，会引发 TypeError；

- 如果 a[x] 是一个字符串或者字节串，而对应的内容又无法处理成 int 时，将引发 ValueError。

  ```python
  int('abc')  # ValueError: invalid literal for int() with base 10: 'abc'
  ```

  

### 说说对 Python 中的浅拷贝和深拷贝的理解？

浅拷贝创建一个新对象，但只复制了原始对象中的顶层元素，而不会复制嵌套对象的子对象。如果原始对象包含引用其他对象的子对象，则浅拷贝只是复制了这些引用，而不是实际的对象。因此，**当对浅拷贝进行修改时，原始对象中的嵌套对象也会受到影响**。

浅拷贝可以使用 `copy()` 方法来实现，或者使用切片操作符 `[:]`。

深拷贝创建一个新对象，并递归地复制原始对象及其所有子对象。深拷贝会完全复制原始对象的所有内容，因此**修改深拷贝的副本不会影响原始对象**。

深拷贝可以使用 `copy.deepcopy()` 方法来实现。



### 说一下 Python 中变量的作用域？

**局部作用域**指的是在函数内部定义的变量的作用范围。这些变量只能在函数内部访问，不能在函数外部访问。

**全局作用域**指的是在模块（文件）顶层定义的变量的作用范围。这些变量可以在整个模块中的任何地方访问。

**内置作用域**指的是Python内置的函数和变量的作用范围。这些函数和变量可以在任何地方直接使用，无需导入任何模块。

**嵌套作用域**指的是在函数内部定义的函数的作用范围。这些内部函数可以访问外部函数的变量。



### Python迭代器

可迭代对象是迭代器、生成器和装饰器的基础。可以使用for来循环遍历的对象就是可迭代对象。比如常见的list、set和dict。

**所有实现了**iter**和**next**两个方法的对象，都是迭代器。**迭代器是带状态的对象，它会记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。**iter**返回迭代器自身，**next**返回容器中的下一个值，如果容器中没有更多元素了，则抛出Stoplteration异常。



### Python生成器

我们创建列表的时候，受到内存限制，容量肯定是有限的，而且不可能全部给他一次枚举出来。Python常用的列表生成式有一个致命的缺点就是定义即生成，非常的浪费空间和效率。

进行函数调用的时候，返回一个生成器对象。在使用next()调用的时候，遇到yield就返回，记录此时的函数调用位置，下次调用next()时，从断点处开始。

```python
a = [x*x for x in range(10)]
```

```python
def spam():
    yield "first"
    yield "second"
    yield "third"
    
for x in spam():
    print(x)
```



### 装饰器--语法糖

```pytho
import logging

def use_log(func):
    def wrapper(*args, **kwargs):
        logging.warning('%s is running' % func.__name__)
        return func(*args, **kwargs)

    return wrapper


@use_log
def bar():
    print('I am bar')


@use_log
def haha():
    print('I am haha')


bar()
haha()

------------结果如下------------
WARNING:root:bar is running
I am bar
WARNING:root:haha is running
I am haha
```



### python是解释语言还是编译语言

Python是解释语言。

解释语言的优点是可移植性好，缺点是运行需要解释环境，运行起来比编译语言要慢，占用的资源也要多一些，代码效率低。

编译语言的优点是运行速度快，代码效率高，编译后程序不可以修改，保密性好。缺点是代码需要经过编译才能运行，可移植性较差，只能在兼容的操作系统上运行。



### python垃圾回收机制

在Python中，使用引用计数进行垃圾回收；同时通过标记-清除算法解决容器对象可能产生的循环引用问题；最后通过分代回收算法提高垃圾回收效率。



### python有多线程吗

Python里的多线程是假的多线程。

Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核，只有一个线程在解释器中运行。

对于I/O密集型任务，Python的多线程能起到作用，但对于CPU密集型任务，Python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。



### Python中range和xrange的区别？

首先，xrange函数和range函数的用法完全相同，不同的地方是xrange函数生成的不是一个list对象，而是一个生成器。

要生成很大的数字序列时，使用xrange会比range的性能优很多，因为其不需要一上来就开辟很大的内存空间。



### Python中列表和元组的区别？

1. **列表是可变的**，在创建之后可以对其进行任意的修改。

2. **元组是不可变的**，元组一旦创建，便不能对其进行更改，可以元组当作一个只读版本的列表。

3. **元组无法复制。**

4. Python将低开销的较大的块分配给元组，因为它们是不可变的。对于列表则分配小内存块。与列表相比，元组的内存更小。当你拥有大量元素时，元组比列表快。



### Python中的异常处理

try和except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。

```python
try:
    6688 / 0
except:
    '''异常的父类，可以捕获所有的异常'''
    print "0不能被除"
else:
    '''保护不抛出异常的代码'''
    print "没有异常"
finally:
    print "最后总是要执行我"
```



## Python中remove，del以及pop之间的区别？

remove，del以及pop都可以用于**删除列表、字符串等里面的元素**，但是具体用法并不相同。

1. remove是剔除第一个匹配的值。
2. del是通过索引来删除当中的元素。
3. pop是通过索引来删除当中的元素，并且返回该元素；若括号内不添加索引值，则默认删除最后一个元素。



### Python中的None

None是一个特殊的常量，表示空值，其和False，0以及空字符串不同，它是一个特殊Python对象, None的类型是NoneType。



### Pytorch动态图和TensorFlow静态图的区别

PyTorch动态图：计算图的运算与搭建同时进行；其较灵活，易调节。

TensorFlow静态图：计算图先搭建图，后运算；其较高效，不灵活。



















