### 图像膨胀与腐蚀

采用卷积操作。

**膨胀：**对图像中的每一个像素，膨胀操作会将其周围的像素置为前景，如果窗口种有一个像素是前景，那么该像素也会被置为前景。

**腐蚀：**对图像中的每一个像素，腐蚀操作会将其周围的像素置为背景，只有当结构元素完全包含目标区域时，该像素才会保持为前景，否则会被置为背景。



### 直方图均衡化

直方图均衡化的目的是使得图像的灰度级别分布更加均匀，从而提高图像的视觉质量。它尤其适用于那些灰度分布不均匀、对比度较低的图像。

**计算原始图像的灰度直方图：**对输入的灰度图像进行扫描，统计每个灰度级别的像素数量，从而得到原始图像的灰度直方图。

**计算累计分布函数（CDF）：**基于原始图像的灰度直方图，计算每个灰度级别的累积分布函数。即累积了每个灰度级别以下的像素数量占总像素数量的比例。

**进行直方图均衡化：**对于原始图像中的每个像素，将其灰度级别替换为对应的CDF值，即将原始灰度级别映射到新的灰度级别。这个映射过程可以通过**插值**等技术来实现，确保灰度级别的变换是平滑的。

**生成增强后的图像：**经过直方图均衡化处理后，得到的图像具有更均匀的灰度分布，增强了图像的对比度和视觉效果。



### 图像的方差

图像的方差越大，说明图像中的灰度值（或颜色值）变化越剧烈，图像的对比度也可能更高；而方差较小则表示图像的灰度值（或颜色值）变化较为平缓。图像方差在图像处理和计算机视觉领域中有多种应用，例如用于图像质量评估、图像增强、特征提取等。



### 图像边缘检测算子有哪些？

1. Sobel算子：一种基于一阶梯度的边缘检测算子，用于寻找图像中的水平和垂直边缘。Sobel算子包含两个卷积核：一个用于计算水平方向的梯度，另一个用于计算垂直方向的梯度。

$$
G_x=\begin{matrix}
-1&0&1\\
-2&0&2\\
-1&0&1\\
\end{matrix}
$$

$$
G_y=\begin{matrix}
-1&-2&-1\\
0&0&0\\
1&2&1\\
\end{matrix}
$$



2. Prewitt算子：类似于Sobel算子，也是一种基于一阶梯度的边缘检测算子，用于寻找图像中的水平和垂直边缘。

$$
G_x=\begin{matrix}
-1&0&1\\
-1&0&1\\
-1&0&1\\
\end{matrix}
$$

$$
G_y=\begin{matrix}
1&1&1\\
0&0&0\\
1&1&1\\
\end{matrix}
$$



3. Laplacian算子：
   $$
   f'(x,y)=-4f(x,y)+f(x-1,y)+f(x+1,y)+f(x,y-1)+f(x,y+1)
   $$




### Canny算子的流程

1. 高斯滤波：滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。

2. 计算梯度值和梯度方向：通过点乘一个sobel或其他算子得到不同方向的梯度值$g_x(m,n)$,$g_y(m,n)$。综合梯度通过以下公式计算梯度值和梯度方向：
   $$
   G(m,n)=\sqrt{g_x(m,n)^2+g_y(m,n)^2}
   $$

   $$
   \theta=arctan \frac{g_y(m,n)}{g_x(m,n)}
   $$

3. 非极大值抑制：使边缘的宽度尽可能为1个像素点，如果一个像素点属于边缘， 那么这个像素点在梯度方向上的梯度值是最大的，否则不是边缘，将灰度值设置为0.

4. 使用上下阈值来检测边缘：设置两个threshold，分别为maxVal和minVal。其中大于maxVal的都被检测为边缘，而低于minval的都被检测为非边缘。对于中间的像素点，如果与确定为边缘的像素点邻接，则判定为边缘；否则为非边缘。



### 仿射变换

图像的仿射变换是指通过线性变换来对图像进行**平移**、**旋转**、**缩放**和**剪切**等操作，而不改变图像的**平行性**和**直线性**。

一个集合的仿射变换为$f(x)=Ax+b$
$$
\left[
\begin{matrix}
    x' \\ y' \\ 1
\end{matrix}
\right]
=
\left[
\begin{matrix}
R_{00} & R_{01} & T_x \\
R_{10} & R_{11} & T_y \\
0 & 0 & 1
\end{matrix}
\right]
\left[
\begin{matrix}
x \\ y \\ 1
\end{matrix}
\right]
$$
**平移变换：**
$$
M=
\left[
\begin{matrix}
1 & 0 & T_x \\
0 & 1 & T_y \\
0 & 0 & 1
\end{matrix}
\right]
$$

$$
x'=x+T_x
$$

$$
y'=y+T_y
$$



**旋转变换：**
$$
M=
\left[
\begin{matrix}
cos\theta & -sin\theta & 0 \\
sin\theta & cos\theta & 0 \\
0 & 0 & 1
\end{matrix}
\right]
$$

$$
x'=cos\theta x - sin\theta y
$$

$$
y'=sin\theta x + cos\theta y
$$

**缩放变换：**
$$
M=
\left[
\begin{matrix}
a_{11} & 0 & 0 \\
0 & a_{22} & 0 \\
0 & 0 & 1
\end{matrix}
\right]
$$

我们这边采用的方法其实就是人工选取3组对应点，将三组对应点带入到仿射变换矩阵中，做一个方程组的求解；



### 最邻近插值

首先假设原图是一个像素大小为W*H的图片，缩放后的图片是一个像素大小为w*h的图片，这时候我们是已知原图中每个像素点上的像素值（即灰度值等）的（⚠️像素点对应像素值的坐标都是整数）。这个时候已知缩放后有一个像素点为(x,y)，想要得到该像素点的像素值，那么就要根据缩放比例去查看其对应的原图的像素点的像素值，然后将该像素值赋值给该缩放后图片的像素点(x,y)

- 根据横轴，即宽可得：X/x = W/w
- 根据纵轴，即高可得：Y/y = H/h
- 那么能够得到 f（X,Y）= f( W/w * x, H/h *y)

因为缩放比例的原因，会导致像素点( W/w * x, H/h *y)中的值不是整数，所以最邻近插值采用向下取整的方法。



### 双线性插值

![img](https://pic1.zhimg.com/80/v2-cb1e4844e85e1442f045d52c00f0f35c_1440w.webp)

我们需要计算出P点的像素值。我们取P点邻近的四个点Q11,Q12,Q21,Q22，并假设在邻近范围内，点的像素值是呈线性变化的。
$$
f(R1)=\frac{x2-x}{x2-x1}f(Q11)+\frac{x-x1}{x2-x1}f(Q21)
$$

$$
f(R2)=\frac{x2-x}{x2-x1}f(Q12)+\frac{x-x1}{x2-x1}f(Q22)
$$

$$
f(P)=\frac{y2-y}{y2-y1}f(R1)+\frac{y-y1}{y2-y1}f(R2)
$$

### 双三次线性插值

![img](https://img-blog.csdn.net/20180924172119995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MzQ4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

双三次插值法需要P点近邻的16个点来加权。

首先构造一个BiCubic函数，它是用来根据近邻点与P点的相对位置来计算该点前的权值的一个函数：
$$
W(x) =
\left\{
\begin{array} \\
1-2|x|^2+|x|^3,|x|<1 \\
4-8|x|+5|x|^2-|x|^3,1<=|x|<2 \\
0, |x|>=2 \\
\end{array}
\right.
$$
![img](https://img-blog.csdn.net/20180924172122791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MzQ4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

得到权值后，我们只需要将这16个点的像素值加权起来即可，插值计算的公式如下：

$$
f(x,y)=\sum_{i}^3\sum_{j=0}^3f(x_i,y_i)W(x-x_i)W(y-y_i)
$$

### 拉普拉斯变换

拉普拉斯变换也可以用作[边缘检测](https://so.csdn.net/so/search?q=边缘检测&spm=1001.2101.3001.7020)，用二次导数的形式定义。
$$
Laplace(f)=\frac{\partial^2 f}{\partial^2 x} + \frac{\partial^2 f}{\partial^2 y}
$$
拉普拉斯算子：
$$
\left [
\begin{matrix}
0& 1 & 0 \\
1 & -4 & 1 \\
0& 1 & 0 \\
\end{matrix}
\right ]
$$

### 怎么构建图像金字塔

一种是高斯[金字塔](https://so.csdn.net/so/search?q=金字塔&spm=1001.2101.3001.7020)（Gaussian Pyramid），另一种的拉普拉斯金字塔（Laplacian Pyramid）。

高斯金字塔通过不断对图像进行模糊且下采样而获得，下采样的因子一般是2倍。随着分辨率越来越小，图像会越来越模糊，高斯金字塔的最底层就是原始图像本身。

拉普拉斯金字塔在高斯金字塔的基础上，对所有层进行上采样（一般也是2倍上采样），然后使用原高斯金字塔结果减去通分辨率的上采样结果得到每一层差异，即为拉普拉斯金字塔。

拉普拉斯金字塔中，大部分的数值接近于0，所以一定程度上可以用于图像压缩。拉普拉斯金字塔还常用于图像融合，基于拉普拉斯金字塔的图像融合，融合边界的过渡往往会相对自然一些。

上下采样均需要做模糊，下采样中做模糊是为了防止锯齿现象，上采样中做模糊是因为图像金字塔分解中的上采样比较“特别”，不做模糊不行。

下采样：对图像做模糊，然后直接每隔一个像素抽一个数据即可实现2倍下采样。

上采样：将每个像素扩展成2x2的小区域，原像素放在左上角，其他3个位置补0，然后将卷积核乘以4，再对扩展后的图像做模糊即可。



### 分水岭算法原理

图像的灰度空间很像地球表面的整个地理结构，每个像素的灰度值代表高度。其中的灰度值较大的像素连成的线可以看做山脊，也就是分水岭。其中的水就是用于二值化的gray threshold level，二值化阈值可以理解为水平面，比水平面低的区域会被淹没，刚开始用水填充每个孤立的山谷(局部最小值)。

当水平面上升到一定高度时，水就会溢出当前山谷，可以通过在分水岭上修大坝，从而避免两个山谷的水汇集，这样图像就被分成2个像素集，一个是被水淹没的山谷像素集，一个是分水岭线像素集。最终这些大坝形成的线就对整个图像进行了分区，实现对图像的分割。

首先找到一个局部极小值区域，作为漫水点，紧接开始灌水，这个扩城延续到达到水位的最大值，其中的山谷即为分水岭。

![img](https://pic2.zhimg.com/80/v2-ea8ce5a64e744c8c56c492b03a039265_720w.webp)

然而分水岭算法对噪声等影响非常敏感。所以在真实图像中，由于噪声点或者其它干扰因素的存在，使用分水岭算法常常存在过度分割的现象，这是因为很多很小的局部极值点的存在。为了解决过度分割的问题，可以使用基于标记(mark)图像的分水岭算法，就是通过先验知识，来指导分水岭算法，以便获得更好的图像分段效果。

```python
x, y = np.indices((80, 80))
x1, y1, x2, y2 = 28, 28, 44, 52
r1, r2 = 16, 20
mask_circle1 = (x - x1)**2 + (y - y1)**2 < r1**2
mask_circle2 = (x - x2)**2 + (y - y2)**2 < r2**2
image = np.logical_or(mask_circle1, mask_circle2)
from scipy import ndimage as ndi
distance = ndi.distance_transform_edt(image)
from skimage.feature import peak_local_max
local_maxi = peak_local_max(distance, labels=image, footprint=np.ones((3, 3)),  indices=False)
markers = ndi.label(local_maxi)[0]
labels = watershed(-distance, markers, mask=image)
# markers: 为手工标记的区域
# mask: 限制了分水岭的标记区域
```



### 霍夫变换原理

直线的方程为$y=mx+b$，$r=xcos\theta+ysin\theta$。可以将图像的每一条直线与一对参数相关联，这个参数空间被称为霍夫空间。对于图像中的每个边缘点，根据其在参数空间中的曲线，对直线的参数空间进行累加，如果多个边缘点共线，那么他们对应的直线在参数空间中的曲线将交于共同的点。

![图1](https://img-blog.csdn.net/20180429101617112)

![图2](https://img-blog.csdn.net/2018042910181487)







### 匈牙利匹配原理

1. 行归约，减去每行最小值。 2. 列归约，减去每列最小值。 3. 做循环： 3A. 用尽量少的线覆盖住矩阵中所有的零元素。 3B. 判断是否终止循环，条件，线的数量是否等于节点的数量。 3C. 创造更多的零元素，寻找所有元素中没有被线覆盖的最小元素，将其他未被线覆盖的元素减去最小的元素，同时要将最小元素加到线的交叉处。



### SIFT特征点提取

尺度不变特征变换(Scale-invariant feature transform， 简称SIFT)是图像局部特征提取的现代方法。SIFT特征是图像的局部特征，其对**旋转、尺度缩放、亮度**变化保持不变性，对**视角变化、仿射变换、噪声**也保持一定程度的稳定性。

**尺度空间：**

一个图像的尺度空间$L(x,y,\sigma)$，定义一个变换尺度的高斯函数$G(x,y,\sigma)$与原图像$l(x,y)$的卷积。
$$
L(x,y,\sigma)=G(x,y,\sigma)*I(x,y)
$$
$\sigma$为尺度空间因子，越小表示图像被平滑越少，相应尺度就越小。小尺度对应于图像的细节特征，大尺度对应于图像的概貌特征。

**建立高斯金字塔**

对图像做不同尺度的高斯模糊，对图像做降采样（各点采样），建立DOG高斯差分金字塔。

DOG函数：
$$
D(x,y,\sigma)=[G(x,y,k\sigma)-G(x,y,\sigma)]*I(x,y)=L(x,y,k\sigma)-L(x,y,\sigma)
$$
DOG在计算上只需相邻高斯平滑后图像相减，因此简化了计算！

可以通过高斯差分图像看出图像上的像素值变化情况。（如果没有变化，也就没有特征。特征必须是变化尽可能多的点。）DOG图像描绘的是目标的轮廓。

**DOG局部极值检测**

特征点是由DOG空间的局部极值点组成的。为了寻找DOG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域 的相邻点大或者小。

![img](https://img-blog.csdnimg.cn/20190316143237143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzY5OTI2,size_16,color_FFFFFF,t_70)

中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个 点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。

**关键点匹配：**

模板图中的关键点描述子：$R_i=(r_{i1},r_{i2},...r_{i128})$，待匹配图中的关键点描述子：$S_i=(s_{i1},s_{i2},...s_{i128})$.

任意两组描述子的相似性度量$d(R_i, S_i)=\sqrt{\sum_{j=1}^{128}(r_{ij}-s_{ij})^2}$

关键点的匹配可以采用穷举法来完成，但是这样耗费的时间太多，一 般都采用kd树的数据结构来完成搜索。搜索的内容是以目标图像的关键点为基准，搜索与目标图像的特征点最邻近的原图像特征点和次邻近的原图像特征点。



### 图像配准

![img](https://pic3.zhimg.com/80/v2-63aba3dec4ed09966c8122e9fa1ad5d6_720w.webp)



### RANSAC

RANSAC（Random Sample Consensus，随机样本一致性）是一种经典的迭代方法，用于估计数学模型参数，以从包含噪声的数据中找到正确的模型参数。RANSAC适用于处理具有大量噪声的数据，可以在其中找到最优的模型参数。

1. **随机采样**：从数据集中随机选择一定数量的样本，以构建一个初始的模型。
2. **模型拟合**：使用随机选择的样本来拟合一个模型。模型的参数根据选定的算法（例如线性回归、多项式拟合、几何模型等）来计算。
3. **内点检验**：对于每个数据点，计算它与拟合模型的适应度（通常是距离或误差度量）。如果数据点适合于当前模型（即在某个阈值范围内），则将其标记为内点；否则将其标记为外点。
4. **模型评估**：根据内点的数量来评估拟合的模型的质量。内点数量越多，模型越可能是正确的。
5. **迭代**：重复上述过程多次（迭代次数由用户指定），选择具有最大内点数量的模型作为最终的模型。