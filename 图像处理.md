### 图像膨胀与腐蚀

采用卷积操作。

**膨胀：**对图像中的每一个像素，膨胀操作会将其周围的像素置为前景，如果窗口种有一个像素是前景，那么该像素也会被置为前景。

**腐蚀：**对图像中的每一个像素，腐蚀操作会将其周围的像素置为背景，只有当结构元素完全包含目标区域时，该像素才会保持为前景，否则会被置为背景。



### 直方图均衡化

直方图均衡化的目的是使得图像的灰度级别分布更加均匀，从而提高图像的视觉质量。它尤其适用于那些灰度分布不均匀、对比度较低的图像。

**计算原始图像的灰度直方图：**对输入的灰度图像进行扫描，统计每个灰度级别的像素数量，从而得到原始图像的灰度直方图。

**计算累计分布函数（CDF）：**基于原始图像的灰度直方图，计算每个灰度级别的累积分布函数。即累积了每个灰度级别以下的像素数量占总像素数量的比例。

**进行直方图均衡化：**对于原始图像中的每个像素，将其灰度级别替换为对应的CDF值，即将原始灰度级别映射到新的灰度级别。这个映射过程可以通过**插值**等技术来实现，确保灰度级别的变换是平滑的。

**生成增强后的图像：**经过直方图均衡化处理后，得到的图像具有更均匀的灰度分布，增强了图像的对比度和视觉效果。



### 图像的方差

图像的方差越大，说明图像中的灰度值（或颜色值）变化越剧烈，图像的对比度也可能更高；而方差较小则表示图像的灰度值（或颜色值）变化较为平缓。图像方差在图像处理和计算机视觉领域中有多种应用，例如用于图像质量评估、图像增强、特征提取等。



### 色彩空间RGB，HSV，YCbCr

1. RGB:基于人眼对红、绿、蓝三原色光混合感知其他颜色的原理建立的。在数字图像中，每个像素通常由三个分量组成，分别表示红色、绿色和蓝色的强度。RGB色彩空间广泛应用于显示器、电视、数码相机等电子设备，因为这些设备通过发射红、绿、蓝三色光来合成各种颜色。

​	**缺点：**自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。

2. HSI色彩空间：（色调、饱和度、强度）空间，是一种更符合人描述和解释颜色的一种模型。它还有一个优点：可以解除图像中的颜色和灰度信息的联系，使其更适合某些灰度处理技术。

3. HSV颜色空间：（色调、饱和度、亮度）空间，不适合显示器系统，但是更符合人眼的视觉特性，因此通常会将颜色从RGB空间域转换到HSV颜色空间进行处理，然后在换回RGB域进行显示；

![img](https://pic1.zhimg.com/80/v2-e9f9c843e7d60e8f7aa7de1cd61d1818_720w.webp)

4. YCbCr颜色空间：YCbCr是一种广泛应用于数字视频、图像编码和传输的标准色彩空间，特别适用于电视广播、数字视频压缩（如MPEG、JPEG）等领域。它将颜色分解为亮度（Luminance, Y）和色度（Chrominance, Cb和Cr）两部分，实现了对人眼对亮度敏感特性的优化利用，有助于提高数据压缩效率。**Y**分量代表图像的亮度或灰度信息，相当于图像的黑白版本。**Cb**和**Cr**分量代表颜色的色度信息，即除亮度之外的颜色成分。**Cb**（或有时记作U）对应蓝色色度，描述图像中颜色相对于亮度的偏蓝或偏黄的程度。**Cr**（或有时记作V）对应红色色度，描述图像中颜色相对于亮度的偏红或偏青的程度。



### 图像格式 BMP，JPEG，PNG

**BMP**，全称为Bitmap或Bitmap Image File，是一种无损的位图图像格式。BMP格式存储的是像素的原始数据，不进行任何形式的压缩，因此能完整保留图像的所有细节，无损画质。BMP支持1位（黑白）、4位、8位（256色）、16位（高彩色）、24位（真彩色）和32位（带Alpha通道的真彩色）等多种色彩深度。

**JPEG**是一种有损压缩的图像格式，特别适用于照片和其他含有丰富连续色调的图像。JPEG使用基于离散余弦变换（DCT）的压缩算法，能够在大幅度减少文件大小的同时，保留视觉上的图像质量。压缩过程中会丢失部分细节，但这些丢失通常不易被人眼察觉。JPEG通常使用24位真彩色（8位/通道），足以表现丰富的色彩和细腻的渐变。JPEG格式不支持透明像素，对于需要透明效果的图像，需选择其他格式（如PNG）。

**PNG**是一种无损压缩的位图格式，旨在替代老旧的GIF格式，同时克服其局限性。PNG使用无损压缩算法，保证图像在压缩后不失真。PNG支持Alpha通道，可以实现不同程度的透明效果。PNG支持8位、24位、32位（带Alpha通道）等多种色彩深度。



### 图像低通滤波（平滑）

图像低通滤波是一种图像处理技术，用于**平滑图像**并去除或减弱图像中的高频成分，也就是那些变化剧烈、细节丰富或噪声较多的部分。

可以用于平滑图像，减小噪声；

1. **均值滤波：**将每个像素的值替换为其邻域内所有像素值的平均值，简单且有效，但可能导致边缘模糊。
2. **高斯滤波：**使用高斯核对图像进行卷积，高斯核赋予中心像素更高的权重，远离中心的像素权重逐渐减小。高斯滤波相比均值滤波能更好地保留边缘信息，因为它考虑了距离的影响。
3. **中值滤波：**对每个像素，取其邻域内的所有像素值的中值作为新的像素值。中值滤波对椒盐噪声等脉冲噪声有很好的抑制效果，同时能较好地保护边缘。
4. **傅里叶变换：**将图像从空间域转换到频率域，通过设定截止频率，对高于该频率的成分进行衰减或直接置零，再进行逆傅里叶变换返回到空间域，实现低通滤波。



### 图像高通滤波（锐化）

图像高通滤波，又称图像锐化处理，是一种旨在**增强图像边缘、细节和纹理**的图像处理技术。

1. **Sobel算子**和**Prewitt算子**：通过计算水平和垂直方向的一阶导数（梯度）来检测边缘。
2. **拉普拉斯算子**：计算图像的二阶导数，对边缘和尖锐细节的变化更加敏感，常用于边缘检测和锐化。

3. **傅里叶变换**：将图像从空间域转换到频率域，通过设定截止频率，对低于该频率的成分进行衰减或直接置零，保留高频成分，再进行逆傅里叶变换返回到空间域，实现高通滤波。



### 拉普拉斯变换

拉普拉斯变换也可以用作[边缘检测](https://so.csdn.net/so/search?q=边缘检测&spm=1001.2101.3001.7020)，用二次导数的形式定义。
$$
Laplace(f)=\frac{\partial^2 f}{\partial^2 x} + \frac{\partial^2 f}{\partial^2 y}
$$
拉普拉斯算子：
$$
\left [
\begin{matrix}
0& 1 & 0 \\
1 & -4 & 1 \\
0& 1 & 0 \\
\end{matrix}
\right ]
$$



### 阈值分割

1. 手动设定阈值：对于灰度分布相对简单、对比度明显的图像，可以通过观察直方图或直接查看图像，主观判断一个合适的阈值。
2. Otsu: 这是一种自动阈值选择算法，它根据图像的直方图寻找能够最大化类间方差的阈值，适用于直方图双峰或多峰的情况，能够较好地适应图像整体的灰度分布。



### 图像超分辨率

1. 最邻近插值：直接选取最近的像素值进行放大，但易导致锯齿状边缘和严重的块状效应。
2. 双线性插值：考虑相邻四个像素的加权平均，提供比最近邻插值更平滑的结果，但仍然无法恢复丢失的高频细节。
3. 双三次插值：使用一个三次多项式对每个像素周围16个点进行拟合，产生更平滑的过渡效果，但同样无法创造新的图像细节。
4. 频域方法：通过傅里叶变换、小波变换等在频域中对低频成分进行放大，再进行逆变换得到HR图像。适用于图像具有周期性结构的情况。



### 傅里叶变换

**空间域：**域图像直接反映了物体的空间结构和亮度分布。

**频率域：**在 图像处理中，频域反应了图像在空域灰度变化剧烈程度，也就是图像灰度的变化速度，也就是图像的梯度大小。对图像而言，图像的边缘部分是突变部分，变化较快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。



### 小波变换

**小波变换**（Wavelet Transform, WT）是一种通过对信号（或图像）与一系列不同尺度、不同位置的小波函数进行卷积（或内积）运算，将信号从原始时域（或空间域）映射到小波域的过程。

利用小波的多尺度特性分析图像的不同频率成分，可用于图像去噪、压缩、边缘检测、纹理分析、超分辨率重建等任务。

### 图像去噪

1. 高斯滤波：通过一个二维高斯核对图像进行卷积，平滑图像同时保留边缘信息，对高斯噪声有较好的抑制作用。

2. 均值滤波：计算像素及其邻域内所有像素的平均值作为输出，简单易行但可能导致边缘模糊。

3. 中值滤波：取邻域内像素灰度值的中位数替换中心像素，对椒盐噪声等离散噪声有良好效果，保持边缘清晰。

4. 傅里叶变换：将图像转换到频域，通过设置阈值或滤波器去除高频噪声，再进行逆变换回到空间域。

5. 小波变换：利用小波分析对图像进行多尺度、多方向分解，通过阈值处理或软硬阈值函数在小波系数上进行去噪，保留图像细节。

   

### 图像边缘检测算子有哪些？

1. Sobel算子：一种基于一阶梯度的边缘检测算子，用于寻找图像中的水平和垂直边缘。Sobel算子包含两个卷积核：一个用于计算水平方向的梯度，另一个用于计算垂直方向的梯度。

$$
G_x=\begin{matrix}
-1&0&1\\
-2&0&2\\
-1&0&1\\
\end{matrix}
$$

$$
G_y=\begin{matrix}
-1&-2&-1\\
0&0&0\\
1&2&1\\
\end{matrix}
$$



2. Prewitt算子：类似于Sobel算子，也是一种基于一阶梯度的边缘检测算子，用于寻找图像中的水平和垂直边缘。

$$
G_x=\begin{matrix}
-1&0&1\\
-1&0&1\\
-1&0&1\\
\end{matrix}
$$

$$
G_y=\begin{matrix}
1&1&1\\
0&0&0\\
1&1&1\\
\end{matrix}
$$



3. Laplacian算子：
   $$
   f'(x,y)=-4f(x,y)+f(x-1,y)+f(x+1,y)+f(x,y-1)+f(x,y+1)
   $$




### Canny算子的流程

1. 高斯滤波：滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。

2. 计算梯度值和梯度方向：通过点乘一个sobel或其他算子得到不同方向的梯度值$g_x(m,n)$,$g_y(m,n)$。综合梯度通过以下公式计算梯度值和梯度方向：
   $$
   G(m,n)=\sqrt{g_x(m,n)^2+g_y(m,n)^2}
   $$

   $$
   \theta=arctan \frac{g_y(m,n)}{g_x(m,n)}
   $$

3. 非极大值抑制：使边缘的宽度尽可能为1个像素点，如果一个像素点属于边缘， 那么这个像素点在梯度方向上的梯度值是最大的，否则不是边缘，将灰度值设置为0.

4. 使用上下阈值来检测边缘：设置两个threshold，分别为maxVal和minVal。其中大于maxVal的都被检测为边缘，而低于minval的都被检测为非边缘。对于中间的像素点，如果与确定为边缘的像素点邻接，则判定为边缘；否则为非边缘。



### 仿射变换

图像的仿射变换是指通过线性变换来对图像进行**平移**、**旋转**、**缩放**和**剪切**等操作，而不改变图像的**平行性**和**直线性**。

一个集合的仿射变换为$f(x)=Ax+b$
$$
\left[
\begin{matrix}
    x' \\ y' \\ 1
\end{matrix}
\right]
=
\left[
\begin{matrix}
R_{00} & R_{01} & T_x \\
R_{10} & R_{11} & T_y \\
0 & 0 & 1
\end{matrix}
\right]
\left[
\begin{matrix}
x \\ y \\ 1
\end{matrix}
\right]
$$
**平移变换：**
$$
M=
\left[
\begin{matrix}
1 & 0 & T_x \\
0 & 1 & T_y \\
0 & 0 & 1
\end{matrix}
\right]
$$

$$
x'=x+T_x
$$

$$
y'=y+T_y
$$



**旋转变换：**
$$
M=
\left[
\begin{matrix}
cos\theta & -sin\theta & 0 \\
sin\theta & cos\theta & 0 \\
0 & 0 & 1
\end{matrix}
\right]
$$

$$
x'=cos\theta x - sin\theta y
$$

$$
y'=sin\theta x + cos\theta y
$$

**缩放变换：**
$$
M=
\left[
\begin{matrix}
a_{11} & 0 & 0 \\
0 & a_{22} & 0 \\
0 & 0 & 1
\end{matrix}
\right]
$$

我们这边采用的方法其实就是人工选取3组对应点，将三组对应点带入到仿射变换矩阵中，做一个方程组的求解；



### 最邻近插值

首先假设原图是一个像素大小为W*H的图片，缩放后的图片是一个像素大小为w*h的图片，这时候我们是已知原图中每个像素点上的像素值（即灰度值等）的（⚠️像素点对应像素值的坐标都是整数）。这个时候已知缩放后有一个像素点为(x,y)，想要得到该像素点的像素值，那么就要根据缩放比例去查看其对应的原图的像素点的像素值，然后将该像素值赋值给该缩放后图片的像素点(x,y)

- 根据横轴，即宽可得：X/x = W/w
- 根据纵轴，即高可得：Y/y = H/h
- 那么能够得到 f（X,Y）= f( W/w * x, H/h *y)

因为缩放比例的原因，会导致像素点( W/w * x, H/h *y)中的值不是整数，所以最邻近插值采用向下取整的方法。



### 双线性插值

![img](https://pic1.zhimg.com/80/v2-cb1e4844e85e1442f045d52c00f0f35c_1440w.webp)

我们需要计算出P点的像素值。我们取P点邻近的四个点Q11,Q12,Q21,Q22，并假设在邻近范围内，点的像素值是呈线性变化的。
$$
f(R1)=\frac{x2-x}{x2-x1}f(Q11)+\frac{x-x1}{x2-x1}f(Q21)
$$

$$
f(R2)=\frac{x2-x}{x2-x1}f(Q12)+\frac{x-x1}{x2-x1}f(Q22)
$$

$$
f(P)=\frac{y2-y}{y2-y1}f(R1)+\frac{y-y1}{y2-y1}f(R2)
$$

### 双三次线性插值

![img](https://img-blog.csdn.net/20180924172119995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MzQ4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

双三次插值法需要P点近邻的16个点来加权。

首先构造一个BiCubic函数，它是用来根据近邻点与P点的相对位置来计算该点前的权值的一个函数：
$$
W(x) =
\left\{
\begin{array} \\
1-2|x|^2+|x|^3,|x|<1 \\
4-8|x|+5|x|^2-|x|^3,1<=|x|<2 \\
0, |x|>=2 \\
\end{array}
\right.
$$
![img](https://img-blog.csdn.net/20180924172122791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MzQ4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

得到权值后，我们只需要将这16个点的像素值加权起来即可，插值计算的公式如下：

$$
f(x,y)=\sum_{i}^3\sum_{j=0}^3f(x_i,y_i)W(x-x_i)W(y-y_i)
$$



### 怎么构建图像金字塔

一种是高斯[金字塔](https://so.csdn.net/so/search?q=金字塔&spm=1001.2101.3001.7020)（Gaussian Pyramid），另一种的拉普拉斯金字塔（Laplacian Pyramid）。

高斯金字塔通过不断对图像进行模糊且下采样而获得，下采样的因子一般是2倍。随着分辨率越来越小，图像会越来越模糊，高斯金字塔的最底层就是原始图像本身。

拉普拉斯金字塔在高斯金字塔的基础上，对所有层进行上采样（一般也是2倍上采样），然后使用原高斯金字塔结果减去通分辨率的上采样结果得到每一层差异，即为拉普拉斯金字塔。

拉普拉斯金字塔中，大部分的数值接近于0，所以一定程度上可以用于图像压缩。拉普拉斯金字塔还常用于图像融合，基于拉普拉斯金字塔的图像融合，融合边界的过渡往往会相对自然一些。

上下采样均需要做模糊，下采样中做模糊是为了防止锯齿现象，上采样中做模糊是因为图像金字塔分解中的上采样比较“特别”，不做模糊不行。

下采样：对图像做模糊，然后直接每隔一个像素抽一个数据即可实现2倍下采样。

上采样：将每个像素扩展成2x2的小区域，原像素放在左上角，其他3个位置补0，然后将卷积核乘以4，再对扩展后的图像做模糊即可。



### 分水岭算法原理

图像的灰度空间很像地球表面的整个地理结构，每个像素的灰度值代表高度。其中的灰度值较大的像素连成的线可以看做山脊，也就是分水岭。其中的水就是用于二值化的gray threshold level，二值化阈值可以理解为水平面，比水平面低的区域会被淹没，刚开始用水填充每个孤立的山谷(局部最小值)。

当水平面上升到一定高度时，水就会溢出当前山谷，可以通过在分水岭上修大坝，从而避免两个山谷的水汇集，这样图像就被分成2个像素集，一个是被水淹没的山谷像素集，一个是分水岭线像素集。最终这些大坝形成的线就对整个图像进行了分区，实现对图像的分割。

首先找到一个局部极小值区域，作为漫水点，紧接开始灌水，这个扩城延续到达到水位的最大值，其中的山谷即为分水岭。

![img](https://pic2.zhimg.com/80/v2-ea8ce5a64e744c8c56c492b03a039265_720w.webp)

然而分水岭算法对噪声等影响非常敏感。所以在真实图像中，由于噪声点或者其它干扰因素的存在，使用分水岭算法常常存在过度分割的现象，这是因为很多很小的局部极值点的存在。为了解决过度分割的问题，可以使用基于标记(mark)图像的分水岭算法，就是通过先验知识，来指导分水岭算法，以便获得更好的图像分段效果。

```python
x, y = np.indices((80, 80))
x1, y1, x2, y2 = 28, 28, 44, 52
r1, r2 = 16, 20
mask_circle1 = (x - x1)**2 + (y - y1)**2 < r1**2
mask_circle2 = (x - x2)**2 + (y - y2)**2 < r2**2
image = np.logical_or(mask_circle1, mask_circle2)
from scipy import ndimage as ndi
distance = ndi.distance_transform_edt(image)
from skimage.feature import peak_local_max
local_maxi = peak_local_max(distance, labels=image, footprint=np.ones((3, 3)),  indices=False)
markers = ndi.label(local_maxi)[0]
labels = watershed(-distance, markers, mask=image)
# markers: 为手工标记的区域
# mask: 限制了分水岭的标记区域
```



### 霍夫变换原理

直线的方程为$y=mx+b$，$r=xcos\theta+ysin\theta$。可以将图像的每一条直线与一对参数相关联，这个参数空间被称为霍夫空间。对于图像中的每个边缘点，根据其在参数空间中的曲线，对直线的参数空间进行累加，如果多个边缘点共线，那么他们对应的直线在参数空间中的曲线将交于共同的点。

![图1](https://img-blog.csdn.net/20180429101617112)

![图2](https://img-blog.csdn.net/2018042910181487)







### 匈牙利匹配原理

1. 行归约，减去每行最小值。 2. 列归约，减去每列最小值。 3. 做循环： 3A. 用尽量少的线覆盖住矩阵中所有的零元素。 3B. 判断是否终止循环，条件，线的数量是否等于节点的数量。 3C. 创造更多的零元素，寻找所有元素中没有被线覆盖的最小元素，将其他未被线覆盖的元素减去最小的元素，同时要将最小元素加到线的交叉处。



### SIFT特征点提取

尺度不变特征变换(Scale-invariant feature transform， 简称SIFT)是图像局部特征提取的现代方法。SIFT特征是图像的局部特征，其对**旋转、尺度缩放、亮度**变化保持不变性，对**视角变化、仿射变换、噪声**也保持一定程度的稳定性。

**尺度空间：**

一个图像的尺度空间$L(x,y,\sigma)$，定义一个变换尺度的高斯函数$G(x,y,\sigma)$与原图像$l(x,y)$的卷积。
$$
L(x,y,\sigma)=G(x,y,\sigma)*I(x,y)
$$
$\sigma$为尺度空间因子，越小表示图像被平滑越少，相应尺度就越小。小尺度对应于图像的细节特征，大尺度对应于图像的概貌特征。

**建立高斯金字塔**

对图像做不同尺度的高斯模糊，对图像做降采样（各点采样），建立DOG高斯差分金字塔。

DOG函数：
$$
D(x,y,\sigma)=[G(x,y,k\sigma)-G(x,y,\sigma)]*I(x,y)=L(x,y,k\sigma)-L(x,y,\sigma)
$$
DOG在计算上只需相邻高斯平滑后图像相减，因此简化了计算！

可以通过高斯差分图像看出图像上的像素值变化情况。（如果没有变化，也就没有特征。特征必须是变化尽可能多的点。）DOG图像描绘的是目标的轮廓。

**DOG局部极值检测**

特征点是由DOG空间的局部极值点组成的。为了寻找DOG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域 的相邻点大或者小。

![img](https://img-blog.csdnimg.cn/20190316143237143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzY5OTI2,size_16,color_FFFFFF,t_70)

中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个 点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。

**关键点匹配：**

模板图中的关键点描述子：$R_i=(r_{i1},r_{i2},...r_{i128})$，待匹配图中的关键点描述子：$S_i=(s_{i1},s_{i2},...s_{i128})$.

任意两组描述子的相似性度量$d(R_i, S_i)=\sqrt{\sum_{j=1}^{128}(r_{ij}-s_{ij})^2}$

关键点的匹配可以采用穷举法来完成，但是这样耗费的时间太多，一 般都采用kd树的数据结构来完成搜索。搜索的内容是以目标图像的关键点为基准，搜索与目标图像的特征点最邻近的原图像特征点和次邻近的原图像特征点。



### 图像配准

![img](https://pic3.zhimg.com/80/v2-63aba3dec4ed09966c8122e9fa1ad5d6_720w.webp)



### RANSAC

RANSAC（Random Sample Consensus，随机样本一致性）是一种经典的迭代方法，用于估计数学模型参数，以从包含噪声的数据中找到正确的模型参数。RANSAC适用于处理具有大量噪声的数据，可以在其中找到最优的模型参数。

1. **随机采样**：从数据集中随机选择一定数量的样本，以构建一个初始的模型。
2. **模型拟合**：使用随机选择的样本来拟合一个模型。模型的参数根据选定的算法（例如线性回归、多项式拟合、几何模型等）来计算。
3. **内点检验**：对于每个数据点，计算它与拟合模型的适应度（通常是距离或误差度量）。如果数据点适合于当前模型（即在某个阈值范围内），则将其标记为内点；否则将其标记为外点。
4. **模型评估**：根据内点的数量来评估拟合的模型的质量。内点数量越多，模型越可能是正确的。
5. **迭代**：重复上述过程多次（迭代次数由用户指定），选择具有最大内点数量的模型作为最终的模型。