### 贝叶斯定理的作用

通常，事件A在事件B已发生的条件下发生的概率，与事件B在事件A已发生的条件下发生的概率是不一样的。然而，这两者是有确定的关系的，贝叶斯定理就是这种关系的陈述。贝叶斯公式的一个用途，即透过已知的三个概率而推出第四个概率。



### 贝叶斯公式

$$
P(A|B)=\frac{P(B|A)P(A)}{P(B)}
$$

$P(A|B)$是在给定B的条件下A的概率，成为后验概率；

$P(B|A)$是在给定A的条件下B的概率，称为似然度；

$P(A)$是A的先验概率；



### 贝叶斯推断

1. 确定先验分布：先验分布可以是任何合适的概率分布，它反映了我们在观察到数据之前对参数的信念。
2. 计算似然函数：似然函数描述了参数值和数据之间的关系。
3. 应用贝叶斯定理：后验分布正比于先验分布与似然函数的乘积

$$
P(\theta|D)∝P(D|\theta)P(\theta)
$$

$P(\theta|D)$表示给定观察到的数据$D$后参数$\theta$的后验分布，$P(D|\theta)$是在给定参数$\theta$的情况下观察到数据$D$的概率（似然函数），$P(\theta)$是参数的先验分布。

### 条件概率

条件概率是指在已知某一事件发生的条件下，另一事件发生的概率。
$$
P(A|B)=\frac{P(A\bigcap B)}{P(B)}
$$

### 全概率公式

全概率公式是指当某一事件可以被划分为多个互斥事件的并集时，可以利用这些互斥事件的概率以及它们与另一事件的交集的概率来计算另一事件的概率。
$$
P(A)=\sum_{i=1}^nP(A|B_i)P(B_i)
$$



### 朴素贝叶斯

朴素贝叶斯是基于贝叶斯定理的分类算法，**其“朴素”之处在于假设所有特征都是相互独立的，这个假设使得计算条件概率变得更简单**。根据贝叶斯定理，朴素贝叶斯模型可以通过计算每个类别的后验概率，选择具有最大后验概率的类别作为预测结果。

**核心公式：**

对于给定的特征$x$和类别$C_k$ ，贝叶斯定理表示为：
$$
P(C_K|x)=\frac{P(x|C_k)P(C_k)}{P(x)}
$$
由于朴素贝叶斯的“朴素”假设，可以将似然概率表示为各个特征的条件概率的乘积：
$$
P(x|C_k)=P(x_1|C_k)P(x_2|C_k)...P(x_n|C_k)
$$
**优点：**

1. 简单而高效，适用于大规模数据集。
2. 对小规模数据也能表现良好。
3. 适用于多类别分类和文本分类问题。
4. 不容易受到异常值的影响。

**缺点：**

1. 朴素贝叶斯假设所有特征相互独立，这在实际数据中可能不成立，影响模型性能。
2. 对于特征空间较大的数据集，模型可能不够灵活，性能可能不如其他更复杂的算法。



### KNN

K最近邻算法是一种基于实例的学习方法，用于分类和回归。对于分类问题，它基于输入样本在特征空间中的最近邻居来进行分类。**算法的核心思想是认为相似的样本在特征空间中有相似的标签**。

**核心公式：**

1. 距离度量：$d(x,y)=\sqrt{\sum_i^n(x_i-y_i)^2}$, $d(x,y)=\sum_i^n|x_i-y_i|$
2. 投票机制：对于分类问题，KNN通过选取离输入样本最近的k个邻居，并以这些邻居中出现最频繁的类别作为输入样本的类别。
3. 回归问题：对于回归问题，KNN通常采用k个最近邻居的平均值来估计目标值。

**优点：**

1. 简单直观，易于实现和理解。
2. 适用于小规模数据集和特征数较少的问题。
3. 在对数据进行适当预处理的情况下，效果通常较好。

**缺点：**

1. 对大规模数据集的计算开销较大。
2. 对异常值敏感。
3. 需要选择合适的距离度量和k值，这可能会影响模型性能。



### SVM

支持向量机是一种用于分类和回归的监督学习模型。在分类问题中，**SVM的目标是找到一个超平面，将数据集分成两个类别，并使得超平面到最近的数据点（支持向量）的距离最大化**。支持向量机还可以通过核函数在高维空间中处理线性不可分的问题。**适合于二分类或者多分类，特征维度较高的问题。**

**核心公式：**

1. 决策函数：对于输入特征向量 x，SVM的决策函数表示为：$f(x)=sign(wx+b)$，$w$是超平面的法向量
2. 间隔：间隔是超平面到最近的数据点的距离。SVM的目标是最大化这个间隔。

**优点：**

1. 在高维空间中有效，适用于特征数较多的问题。
2. 在处理线性可分问题时，具有较高的分类性能。
3. 通过使用不同的核函数，可以处理非线性问题。

**缺点：**

1. 对于大规模数据集和特征数较多的问题，训练时间可能较长。
2. 对噪声和异常值敏感。
3. 需要选择合适的核函数和参数。



### 高斯核函数

$$
K(x,x')=exp(-\frac{||x-x'||^2}{2\sigma^2})
$$

其中，$x$ 和 $x'$ 是输入样本，$|x - x'|$ 是输入样本之间的欧氏距离，$\sigma$​ 是高斯核函数的一个参数，称为核带宽（Kernel Bandwidth）或者高斯核的宽度参数。

高斯核函数的特点是随着输入样本之间的距离增大，核函数的值指数级地减小。当输入样本之间的距离很小时，核函数的值接近1，说明样本之间非常相似；当输入样本之间的距离很大时，核函数的值接近0，说明样本之间不相似。

高斯核函数的核带宽参数 $\sigma$ 对模型的性能和泛化能力具有重要影响。较小的 $\sigma$ 值会导致高斯核函数的影响范围较小，模型可能过拟合；较大的 $\sigma$ 值会导致高斯核函数的影响范围较大，模型可能欠拟合。



#### 逻辑回归

逻辑回归使用一个称为“逻辑函数”或“Sigmoid函数”的函数作为假设函数，Sigmoid函数的公式如下：
$$
z=w_0+w_1x_1+w_2x_x+...+w_nx_n
$$

$$
h_\theta(x)=\frac{1}{1+e^{z}}
$$

其中$h_\theta(x)$是预测概率，$x$是特征向量，$\theta$是模型参数向量。

对数损失函数：$J(\theta)=-[ylog(h_\theta(x))+(1-y)log(1-h_\theta(x))]$

逻辑回归是一种简单而有效的分类算法，特别适用于二分类问题，并且具有良好的解释性。

**优点：**

1. 简单而有效，容易实现和理解。
2. 适用于线性可分或近似可分的数据。
3. 输出结果是概率，可以直观地解释样本属于正类的可能性。

**缺点：**

1. 对于非线性问题的建模能力相对较弱。
2. 对于特征之间存在高度相关性时，逻辑回归可能表现不佳。
3. 对于噪声较大的数据敏感。
4. 不适用于多类别分类问题（通常用于二分类）。



### 逻辑回归为什么用交叉熵

对于二分类问题，交叉熵损失函数的形式为：
$$
J(θ)=−\frac{1}{m}\sum_{i=1}^m[y^{(i)}log(h_θ(x^{(i)}))+(1−y^{(i)})log(1−h_θ(x^{(i)}))]
$$
逻辑回归模型的预测结果 $h_{\theta}(x^{(i)})$ 是一个在 0 到 1 之间的概率值，表示样本 $i$ 属于正例的概率。交叉熵损失函数可以衡量模型预测结果与真实标签之间的差异。当模型的预测结果偏离真实标签较大时，损失函数的值会增大得很快，这样可以更加有效地惩罚模型的错误预测。



### 信息熵与信息增益

信息的作用是：**消除不确定性**

信息量的度量：$I=-log_2(p)$，$p$表示事件发生的概率，一件事件发生的概率越低，信息量越大。

信息熵：**用于衡量随机变量的不确定性或信息量的平均值。**
$$
H(X)=-\sum_{i=1}^np(x_i)logp(x_i)
$$
当X的分布越均匀（即各个事件发生的概率相等）时，信息熵达到最大值，表明不确定性最大；当 X的分布越偏斜（即某些事件发生的概率较大，其他事件发生的概率较小）时，信息熵较小，表明不确定性较小。

条件熵：**用于衡量在给定某个条件下随机变量的不确定性或信息量的平均值。**假设有两个离散型随机变量 *X* 和 *Y*，其中 *X* 是主随机变量，*Y* 是条件随机变量。条件熵$H(Y|X)$表示在给定 *X* 的情况下，*Y* 的不确定性或信息量的平均值。条件熵$H(Y|X)$的定义为：
$$
H(Y|X)=-\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)log_2(\frac{p(x_i,y_j)}{p(x_i)})
$$
**信息增益：**它衡量了在选择某个特征进行划分后，数据集的信息熵的减少程度。信息增益越大，表示使用该特征进行划分后，数据集的不确定性减少得越多，即这个特征对分类的贡献越大，因此被认为是一个更好的划分特征。一个数据集的信息熵为：
$$
H(D)=-\sum_{i=1}^m\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}
$$
假设使用特征A对数据集进行划分,产生了k个子集，则特征A对数据集D的信息增益为：
$$
Gain(D,A)=H(D)-\sum_{j=1}^k\frac{D_j}{D}H(D_j)
$$


### 决策树

决策树是一种基于**树状结构的分类和回归模型**。在决策树中，**每个内部节点表示对某个特征的测试，每个分支代表测试的结果，每个叶节点表示一个类别或回归值**。通过从根节点到叶节点的路径，可以对输入样本进行分类或回归。

特征选择：选择最佳的特征，将数据集分成最具有区分性的子集。树的构建：递归地将数据集划分成子集，直到满足停止条件，如达到最大深度或节点包含的样本数小于某个阈值。

**ID3算法：**其核心是在决策树的各级节点熵使用信息增益方法作为属性的选择标准，来帮助确定生成每个节点时所采用的合适属性

1. 对于每个特征，计算其对数据集的信息增益（Information Gain）或基尼系数（Gini Impurity）等衡量指标。
2. 选择使得信息增益或基尼系数最大的特征作为当前节点的划分特征。

**优点：**

1. 简单直观，易于理解和解释，可视化效果好。
2. 能够处理数值型和类别型数据。
3. 不需要特别的数据准备，如归一化。
4. 在相对较短的时间内能够对大型数据源做出可行且效果良好的结果。

**缺点：**

1. 容易过拟合，特别是在数据维度较高时。
2. 对异常值敏感。
3. 不稳定性高，数据的小变动可能导致树结构的巨大变化。



### Bagging （Booststrap Aggregating）

Bagging 是一种**并行式集成学习方法**，该方法通过**重采样技术生成若干个不同的子训练集**，然后在每个训练集上训练一个分类器，然后采用投票的方式取大多数的结果为模型的最终结果。模型更像是发挥民主作用的人民代表大会制度，还是大部分人说了算的。

每个学习器的训练都是独立的，可以并行计算，因此训练速度较快；通过自助采样的方法可以增加训练数据的多样性，减少过拟合的风险；由于采用了多个学习器的投票或平均的策略，对异常值和噪声有一定的鲁棒性。

典型的 Bagging 算法包括**随机森林（Random Forest）**（集成多个决策树）。



### Boosting

Boosting 模型是通过串行训练一系列弱学习器来构建的。每个弱学习器都**尝试修正前一个学习器的错误**，从而逐步提高整体模型的性能。每个训练样例都有权重，每次训练新分类器的时候都着重训练那些再上一次分类过程中分错的样例，权重会随着迭代次数的变化而变化。模型更像是有了记忆能力，加大力度惩罚那些在上一轮不乖的样例而使得他们越来越听话。



### 随机森林

随机森林是一种**集成学习方法**，**通过构建多个决策树并取其结果的平均值或多数投票来提高模型的性能和泛化能力**。每个决策树都是在不同的数据子集和特征子集上训练的，这样可以增加模型的多样性，减小过拟合风险。

**核心原理：**

**1.  随机选择样本：** 对于每个决策树的训练，从训练集中随机选择一部分样本，有放回地进行采样。

**2.  随机选择特征：** 在每个决策树的每个节点上，随机选择一部分特征进行考虑，以确保决策树的多样性。

**3.  投票或平均：** 对于分类问题，多个树的输出进行投票，对于回归问题，取多个树的平均值。

**优点：**

1. 高准确性：随机森林在许多情况下能够取得很好的性能。
2. 抗过拟合：通过随机选择样本和特征，降低了过拟合的风险。
3. 适用于大规模数据集和高维特征。

**缺点：**

1. 不太容易解释：随机森林中包含多个决策树，难以解释整个模型的逻辑。
2. 训练时间较长：相比于单一决策树，需要训练多个决策树，因此训练时间较长。
3. 对噪声敏感：随机森林可能对噪声敏感，尤其是在数据中存在大量噪声时。



### AdaBoost

 在每一轮训练中，AdaBoost 调整样本的权重，并根据上一轮分类结果对样本进行加权。它**根据每个弱学习器的分类误差来调整样本的权重**，使得在下一轮中难以分类的样本获得更高的权重。



### Gradient Boosting

Gradient Boosting 不是调整样本的权重，而是训练每个弱学习器来**拟合前一个弱学习器的残差**。对于回归问题，残差即为真实值减去当前模型的预测值；对于分类问题，残差通常使用对数损失函数（Log Loss）来计算。



### 介绍KMeans

聚类属于非监督学习，K均值聚类是最基础常用的聚类算法。它的基本思想是，通过迭代寻找K个簇（Cluster）的一种划分方案，使得聚类结果对应的损失函数最小。其中，损失函数可以定义为各个样本距离所属簇中心点的误差平方和：
$$
J(c,u)=\sum_1^n||x_i-\mu_{c_i}||^2
$$
其中$x_i$代表第i个样本，$c_i$是$x_i$所属的簇，$u_{c_i}$是对应簇的中心点。

具体步骤：1.数据预处理，标准化，过滤异常点；2.随机选取K个中心；3。定义损失函数；4.对每个样本，将其分配到距离最近的中心$c_i^t<-argmin_k||x_i-u_k^t||^2$，重新计算类中心$u_k^{t+1}<-argmin_u\sum_{i_i^t=k}^b||x_i-\mu||^2$

优点：1. 高效可伸缩，计算复杂度 为$O(NKt)$接近于线性（N是数据量，K是聚类总数，t是迭代轮数）；2.收敛速度快，原理相对通俗易懂，可解释性强。

缺点：1. 受初始值和异常点影响，聚类结果可能不是全局最优而是局部最优。2. K是超参数，一般需要按经验选择；3. 样本点只能划分到单一的类中。



### KMeans代码

```python
class KMeans:
    def __init__(self, k, max_iter=100):
        self.k = k
        self.max_iter = max_iter

    def fit(self, data):
        self.centroids = data[np.random.choice(data.shape[0], self.k, replace=False)]
        for i in range(self.max_iter):
            distances = np.sqrt(((data[:, np.newaxis, :] - self.centroids[np.newaxis, :, :])**2).sum(axis=-1))
            clusters = np.argmin(distances, axis=1)
            self.centroids = np.array([data[clusters == k].mean(axis=0) for k in range(self.k)])
        print('centroids:', self.centroids)

    def predict(self, x):
        if not hasattr(self, 'centroids'):
            return None
        distances = np.sqrt(((x[np.newaxis, :] - self.centroids)**2).sum(axis=1))
        return distances.argmin()
```



### EM算法

EM算法（Expectation-Maximization Algorithm）是一种用于**求解含有隐变量（latent variables）的概率模型参数**的迭代优化算法。

**E Step:**根据当前的参数估计值，对给定的观测数据计算期望值。
$$
p(z|x,\theta)=\frac{p(x|z, \theta)p(z|\theta)}{p(x|\theta)}
$$
**M step:**使用E步骤中计算得到的后验概率来更新模型参数。具体地，我们通过最大化对数似然函数来更新参数:
$$
\theta^{t+1}=arg {max} \sum_{i=1}^m\sum_zp(z^i|x^i,\theta^t)logp(x^i,z^i|\theta)
$$
**结论：EM算法可以保证收敛到一个稳定点，即EM算法是一定收敛的。**



### 最小二乘法

最小二乘法（Least Squares Method）是一种常用的数学优化技术，用于寻找一组参数，使得给定的数学模型与观测数据之间的残差平方和最小。

假设我们有一组观测数据 $(x_i, y_i)$，我们想要找到一个模型 $f(x; \theta)$，其中 $\theta$ 是参数向量，使得模型的预测值 $f(x_i; \theta)$ 尽可能地接近观测值 $y_i$。我们可以定义一个损失函数，例如残差平方和（Residual Sum of Squares，RSS）：
$$
RSS(\theta)=\sum_{i=1}^n(y-f(x;\theta))^2
$$
对于线性模型，即 $f(x; \theta) = \theta_0 + \theta_1 x$，最小二乘法的解析解可以通过求解正规方程（Normal Equations）得到：
$$
\theta=(X^TX)^{-1}X^Ty
$$
其中 $X$ 是设计矩阵，包含了所有的观测数据 $x_i$，$y$ 是观测数据的向量。



### 线性回归

线性回归是一种用于建模和分析变量之间关系的统计方法，特别是用于预测一个变量（被称为因变量）与一个或多个自变量之间的关系。在简单线性回归中，只有一个自变量，而在多元线性回归中，有多个自变量。使用**最小二乘法**进行优化。

**核心原理：**

在简单线性回归中，我们试图建立一个线性关系模型：
$$
Y=\beta_0+\beta_1X+\epsilon
$$
我们的目标是找到最优的$\beta_0$和$\beta_1$来最小化误差项$\epsilon$ 。

**优点：**

- 简单易于理解和实现。
- 在数据线性关系较强时表现良好。

**缺点：**

- 对异常值和噪声敏感。
- 仅能捕捉线性关系，无法处理非线性关系。



### 逻辑回归和线性回归的区别

**线性回归：**主要用于建立自变量（特征）与连续因变量之间的关系。使用线性函数拟合自变量与因变量之间的关系，模型形式为$y=\beta_0+\beta_1x_1+...+\beta_nx_n+\epsilon$，通常使用最小二乘法来估计模型的参数，目标是最小化实际观测值和模型预测值之间的平方误差；

**逻辑回归：**用于建立自变量与离散因变量之间的关系，使用Sigmoid函数拟合自变量与因变量之间的关系，$P(Y=1|X)=\frac{1}{1+e^{-(\beta_0+\beta_1x_1+...+\beta_nx_n)}}$，通常使用极大似然估计来估计模型参数，目标是最大化给定数据下观测到的样本概率的乘积。



### 决策树回归

决策树回归是一种基于树结构的回归模型，它通过对输入空间进行递归的划分，**将每个划分区域内的样本的目标值取平均值作为预测值**。以下是决策树回归的详细原理和核心公式。

**核心原理：**

1. 决策树的建立：

- 选择最佳的划分特征：通过计算**每个特征的信息增益或均方误差**等指标，选择最佳的特征来进行划分。
- 划分数据集：根据选择的特征进行数据集的划分，形成子节点。
- 递归地建立子树：对每个子节点递归地重复上述步骤，直到满足停止条件。

2. 决策树的回归预测：

对于新的输入样本，通过决策树的结构，从根节点开始逐级判断样本应该属于哪个叶子节点，然后将该叶子节点内训练样本的目标值作为预测值。

3. 决策树回归的核心公式

$$
\hat y_m=\frac{1}{N_m}\sum_{i\in D_m}y_i
$$

其中$D_m$表示第$m$个叶子节点内的样本索引集合，$N_m$表示该叶子节点内的样本数量。



### 什么是线性可分

线性可分是指在特征空间中，存在一个线性超平面可以将不同类别的样本完全分开。换句话说，如果数据集中的正例和负例可以通过一个超平面（即一个线性函数）进行完全分隔，那么这个数据集就是线性可分的。



### 线性模型的定义是什么

在统计学和机器学习中，线性模型指的是模型的预测结果是输入特征的线性组合加上一个常数偏置的形式。具体而言，线性模型的定义如下：

对于一个包含$n$个特征的样本$(x_1, x_2, ..., x_n)$，线性模型的预测结果$y$可以表示为：
$$
y=w_0+w_1x_1+w_2x_2+...+w_nx_n
$$
其中，$w_0$是常数偏置（截距），$w_1, w_2, ..., w_n$是特征的权重（系数）。这个式子是输入特征的线性组合，因此被称为线性模型。



### 常见的非线性表示

1. 多项式特征：将原始特征的多项式组合为新的非线性特征，例如$x^2$
2. 交互特征： 将原始特征进行交叉组合，例如将两个特征进行乘法运算
3. 指数函数，对数函数，双曲函数，sigmoid，relu，高斯核函数



### 如何进行特征选择，不同的方法好处是什么

特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，**提高模型精确度，减少运行时间的目的**。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。

**一般流程：**

1. 生成子集： 搜索特征子集，为评价函数提供特征子集
2. 评价函数： 评价特征子集的好坏
3. 停止准则：与评价函数相关，一般是阈值，评价函数达到一定标准后可以停止搜索
4. 验证过程：在验证数据集上验证选出来的特征子集的有效性

**三类方法：**

1. 过滤法：按照`发散性`或者`相关性`对各个特征进行评分，设定阈值或者待选择特征的个数进行筛选
2. 包装法：根据目标函数，每次选择若干特征或者排除若干特征
3. 嵌入法：使用某些机器学习的模型进行训练，得到各个特征的权值系数，根据系数由大到小选择特征

**过滤法：**

对每个特征$x_i$计算相对于类别标签的信息量$S$，得到n个结果，然后将n个信息$S_i$两从大到小排序。关键问题是采用什么样的方法来度量特征，例如：

- Pearson相关系数
- 卡方验证
- 互信息和最大信息系数
- 距离相关系数
- 方差选择；

**包装法：**

对于每个待选的特征子集，都在训练集上训练一遍模型，然后在测试集上根据误差大小选择出特征子集，通常使用Random Forest,SVM,KNN等等

**嵌入法：**

- 基于惩罚项的特征选择法（L1正则化）：由于L1正则方法具有稀疏解的特征，因此天然具备特征选择的特性
- 基于学习模型的特征排序，针对每个单独的特征和响应变量建立预测模型



### 主成分分析

它通过线性变换将高维数据投影到低维空间中，同时最大程度地保留原始数据的方差。

1. **数据中心化：**对原始数据进行中心化处理，即减去各个特征的均值，使得数据的均值为零。这一步骤可以确保在进行线性变换时，**新的特征空间中的原点在数据的中心**。
2. **协方差矩阵计算：**协方差矩阵反映了各个特征之间的关系，其中每个元素表示对应特征之间的协方差。
3. **特征值的分解：**对协方差矩阵进行特征值分解（Eigen decomposition），得到特征值（eigenvalues）和对应的特征向量（eigenvectors）。特征向量表示了数据在新特征空间中的方向，而特征值则表示了数据在这些方向上的方差大小。
4. **选择主成分：**根据特征值的大小排序特征向量，选择最大的 k 个特征值对应的特征向量作为主成分（Principal Components）。这些主成分是原始数据在新特征空间中的主要方向，它们能够最大程度地保留原始数据的方差。
5. **投影：**将原始数据投影到选定的主成分上，得到低维的特征表示。

![img](https://images2015.cnblogs.com/blog/1042406/201612/1042406-20161231162149992-1521335659.png)



### 什么是模型的偏差和方差

偏差（Bias）：衡量了模型拟合训练数据的能力，偏差反应的是所有采样得到的大小相同的训练集训练出的所有模型的输出平均值和真实label之间的偏差，即模型本身的精确度。

方差也反应了模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。由方差带来的误差通常体现在测试误差相对于训练误差的增量上。**方差越小，模型的泛化能力越高；反之，模型的泛化能力越低**。



### L范数的作用

L范数主要起到了正则化（即用一些先验知识约束或者限制某一抽象问题）的作用，而正则化主要是防止模型过拟合。范数主要用来表征高维空间中的距离，故在一些生成任务中也直接用L范数来度量生成图像与原图像之间的差别。



### Dropout的作用

Dropout是在训练过程中以一定的概率使神经元失活，也就是输出等于0。从而提高模型的泛化能力，减少过拟合。

1. 在Dropout每一轮训练过程中随机丢失神经元的操作相当于多个模型进行取平均，因此用于预测时具有vote的效果。
2. 减少神经元之间复杂的共适应性。当隐藏层神经元被随机删除之后，使得全连接网络具有了一定的稀疏化，从而有效地减轻了不同特征的协同效应。



### 如何找到让F1最高的分类阈值

一般设0.5作为二分类的默认阈值，但一般不是最优阈值。想要精准率高，一般使用高阈值，而想要召回率高，一般使用低阈值。在这种情况下，我们通常可以通过P-R曲线去寻找最优的阈值点或者阈值范围。



### KL散度

KL散度（Kullback-Leibler divergence），可以以称作相对熵（relative entropy）或信息散度（information divergence）。**KL散度的理论意义在于度量两个概率分布之间的差异程度**，当KL散度越大的时候，说明两者的差异程度越大；而当KL散度小的时候，则说明两者的差异程度小。如果两者相同的话，则该KL散度应该为0。
$$
KL(P||Q)=\sum p(x)log\frac{p(x)}{q(x)}=-\sum p(x)log(q(x))+\sum p(x)log(p(x))=H(P,Q)-H(P)
$$
**性质：**

1. KL散度具备非负性
2. KL散度不具备对称性,**KL散度并不是一个度量（metric），即KL散度并非距离**。



### JS散度

JS散度也与KL散度一样具备了测量两个概率分布相似程度的能力，它的计算方法基于KL散度，继承了KL散度的非负性等，但有一点重要的不同，JS散度具备了对称性。
$$
JSD(P||Q)=\frac{1}{2}KL(P||M)+\frac{1}{2}KL(Q||M)
$$
其$M=\frac{1}{2}×(P+Q)$​。如果两个分布P，Q离得很远，完全没有重叠的时候，那么KL散度值是没有意义的，而JS散度值是一个常数log2。此时，KL散度会导致梯度爆炸，而JS散度会导致梯度消失。



### 有哪些召回和排序的方法

推荐系统流程一般会有四个环节，其中分别为：召回->粗排->精排(Ranking)->重排(ReRank)。

1. 召回：首先是因为面临的侯选数据集非常大，怎么快怎么来，但是也要兼顾用户兴趣。
2. 粗排：有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序
3. 精排：它和召回阶段的特性完全不一样，ranking阶段只有一点需要记住：模型要够准，这是它的根本。**怎么准怎么来**。
4. 重排：重排是做打散或满足业务运营的特定强插需求

**常见的召回算法：**

1. 基于内容的召回：通过item之间的相似性推荐与用户喜欢的item相似的item。
2. 协同过滤：使用用户和item之间的相似性来进行推荐。
3. 基于FM模型的召回：利用矩阵分解的二阶特征组合的推荐算法。

**常见的排序算法：**

1. 基于规则的排序：这种方法通常依赖于业务逻辑，例如根据商品销量、用户评分或时间新鲜度等因素来排序。
2. 机器学习排序：融入大量特征并使用复杂模型来提高推荐的准确性。例如，逻辑回归（LR）、梯度提升决策树（GBDT）、混合推荐模型等。



**主流的召回算法：**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82UWpKWmJxNDJSWkJpY2hNcDlUT1dta05QZGU5VTFla25MOXV2dzZFdEJIajNlYWlhb2VVaFFWVkgzdExiVGQxSlRGZE50OHMyOVg5Um01YTcwaWFFUGdJZy82NDA?x-oss-process=image/format,png)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82UWpKWmJxNDJSWkJpY2hNcDlUT1dta05QZGU5VTFla25FV3ZOQ1loaWI4OGFWREtUblNIMFVSdHJWZEVNREtDZmZMSzcyQVhhcFRVVGZyQWREaWF1UFc3QS82NDA?x-oss-process=image/format,png)

对于传统的矩阵分解来说，是把$m\times n(user\times items)$的矩阵分解成$m\times k$的用户矩阵和$n\times k$的物品矩阵，而DeepMF则使用了一种得到k维隐向量的方式，先把用户交互矩阵分解出代表用户的行和代表物品的列，用一个NN模型去学习用户行和物品列的隐式表达。



![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82UWpKWmJxNDJSWkJpY2hNcDlUT1dta05QZGU5VTFla244STUwS2FrQzhLaWNMMDZZRk9WcG9LVXJEak82N2JvWHZuMTZIaGlhZ1kzdzRMeDBiOWpCOERWdy82NDA?x-oss-process=image/format,png)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82UWpKWmJxNDJSWkJpY2hNcDlUT1dta05QZGU5VTFla25lV25SYUtrZFg3N0FjcUpuZ1N2SDFYVnhUeVNBV0NpYXE0MzI0YXVBSkU3QWdpYmliUWZJVWhDRFEvNjQw?x-oss-process=image/format,png)



### 样本不均衡怎么解决

模型会学习到训练集中样本比例的这种先验性信息，以致于实际预测时就会对多数类别有侧重（可能导致多数类精度更好，而少数类比较差）。

**样本层面：**

- 欠采样：减少多数类的数量，随机欠采样可能会导致丢弃含有重要信息的样本。在计算性能足够下，可以考虑数据的分布信息（通常是基于距离的邻域关系）的采样方法，如ENN、NearMiss等。
- 过采样：尽量多地增加少数类的的样本数量，随机过采样或数据增强样本也有可能是强调（或引入）片面噪声，导致过拟合。也可能是引入信息量不大的样本。此时需要考虑的是调整采样方法，或者通过半监督算法(可借鉴Pu-Learning思路)选择增强数据的**较优子集**，以提高模型的泛化能力。
- 数据增强：从原始数据加工出更多数据的表示，提高原数据的数量及质量
  - 单样本增强：主要有几何操作、颜色变换、随机擦除、添加噪声等方法
  - 多样本增强：过组合及转换多个样本，主要SamplePairing、Mixup等方法在特征空间内构造已知样本的邻域值样本。
  - 基于深度学习的数据增强（VAE，GAN）

**损失函数层面：**

- class weight：为不同类别的样本提供不同的权重（少数类有更高的权重），从而模型可以平衡各类别的学习。
- OHEM：核心是选择一些hard examples（多样性和高损失的样本）作为训练的样本
- Focal loss：在交叉熵损失函数（CE）的基础上增加了类别的不同权重以及困难（高损失）样本的权重，以改善模型学习效果。

![img](https://pic1.zhimg.com/80/v2-846cd45950fa30fc4a4fec30aaaff3dc_1440w.webp)

**模型层面：**

- 集成学习：通过重复组合少数类样本与抽样的同样数量的多数类样本，训练若干的分类器进行集成学习。
- 异常检测：类别不平衡很极端的情况下（比如少数类只有几十个样本），将分类问题考虑成异常检测（anomaly detection）问题可能会更好。无监督异常检测按其算法思想大致可分为几类：基于聚类的方法、基于统计的方法、基于深度的方法(孤立森林)、基于分类模型（one-class SVM）以及基于神经网络的方法（自编码器AE）等等。

**评估指标：**

对于分类常用的precision、recall、F1、混淆矩阵，样本不均衡的不同程度，都会明显改变这些指标的表现。

- **AUC对样本的正负样本比例情况是不敏感**，即使正例与负例的比例发生了很大变化，ROC曲线面积也不会产生大的变化。
- 可以通过P-R曲线，选择到较优表现的阈值。
